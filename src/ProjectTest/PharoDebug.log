THERE_BE_DRAGONS_HERE
Message not understood: RBCascadeNode >> #selector
9 October 2024 7:30:40.984 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

RBCascadeNode(Object)>>doesNotUnderstand: #selector
	Receiver: RBCascadeNode((aStream
	 nextPutAll: 'Yield: ';
	 nextPutAll: yield asString))
	Arguments and temporary variables: 
		aMessage: 	selector
		exception: 	Instance of RBCascadeNode did not understand #selector
		resumeValue: 	nil
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter>>isMultiLineMessage:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		aMessageNode: 	RBCascadeNode((aStream
	 nextPutAll: 'Yield: ';
	 nextPutAll:[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])] in [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


OrderedCollection(SequenceableCollection)>>do:separatedBy:
	Receiver: an OrderedCollection(RBMessageNode(aStream nextPutAll: 'Species: ' , species) RBMessag[..]
	Arguments and temporary variables: 
		elementBlock: 	[ :each | 
							self formatCommentsFor: each;
								forma[..]
		separatorBlock: 	[ 
					codeStream nextPut: $;.
					self newLineAfterCasca[..]
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(RBMessageNode(aStream nextPutAll: 'Species: ' , species) RB[..]
		firstIndex: 	1
		lastIndex: 	7


[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self [..]
	Arguments and temporary variables: 
		aBlock: 	[self indent: self indent - anInteger]
		handler: 	[self indent: self indent - anInteger]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	EFFormatter>>visitCascadeNode:
		compiledBlock: 	a CompiledBlock: [ 
			self newLineBeforeFirstCascade
				if[..]
		numArgs: 	0
		receiver: 	an EFFormatter


EFFormatter>>indent:around:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		anInteger: 	1
		aBlock: 	[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
	[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>indentAround:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		aBlock: 	[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
	[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


RBCascadeNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


OrderedCollection(SequenceableCollection)>>withIndexDo:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		elementAndIndexBlock: 	[:statement :i | 
		self visitNode: statement.
		(i <[..]
		index: 	1
	Receiver's instance variables: 
		array: 	<<error during printing>>

EFFormatter>>formatSequenceNodeStatementsFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>visitSequenceNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


RBSequenceNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>format:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ 
		  self class new
			indent: self indent;
			installNewContext: context;
			lookAheadCode: lookAheadCode;
			format: aNode ] in EFFormatter>>formattedSourceFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[self at: key put: aBlock value] in IdentityDictionary(Dictionary)>>at:ifAbsentPut:
	Receiver: an IdentityDictionary(RBMessageNode('Age: ' , age asString)->'''Age: '' , age asString[..]
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array(RBMessageNode('Species: ' , species)->'''Species: '' , spec[..]


IdentityDictionary(Dictionary)>>at:ifAbsent:
	Receiver: an IdentityDictionary(RBMessageNode('Age: ' , age asString)->'''Age: '' , age asString[..]
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array(RBMessageNode('Species: ' , species)->'''Species: '' , spec[..]


IdentityDictionary(Dictionary)>>at:ifAbsentPut:
	Receiver: an IdentityDictionary(RBMessageNode('Age: ' , age asString)->'''Age: '' , age asString[..]
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array(RBMessageNode('Species: ' , species)->'''Species: '' , spec[..]


EFFormatter>>formattedSourceFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>willBeMultiline:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>formatBlock:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ self formatBlock: aBlockNode ] in EFFormatter>>visitBlockNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self formatBlock: aBlockNode ]
	Arguments and temporary variables: 
		aBlock: 	[ codeStream nextPut: bracketString last ]
		handler: 	[ codeStream nextPut: bracketString last ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	EFFormatter>>visitBlockNode:
		compiledBlock: 	a CompiledBlock: [ self formatBlock: aBlockNode ]
		numArgs: 	0
		receiver: 	an EFFormatter


EFFormatter>>bracketWith:around:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	'[]'
		aBlock: 	[ self formatBlock: aBlockNode ]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>visitBlockNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


RBBlockNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]



--- The full stack ---
RBCascadeNode(Object)>>doesNotUnderstand: #selector
EFFormatter>>isMultiLineMessage:
[ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])] in [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
OrderedCollection(SequenceableCollection)>>do:separatedBy:
[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>indent:around:
EFFormatter>>indentAround:
EFFormatter>>visitCascadeNode:
RBCascadeNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
OrderedCollection(SequenceableCollection)>>withIndexDo:
EFFormatter>>formatSequenceNodeStatementsFor:
EFFormatter>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
EFFormatter>>format:
[ 
		  self class new
			indent: self indent;
			installNewContext: context;
			lookAheadCode: lookAheadCode;
			format: aNode ] in EFFormatter>>formattedSourceFor:
[self at: key put: aBlock value] in IdentityDictionary(Dictionary)>>at:ifAbsentPut:
IdentityDictionary(Dictionary)>>at:ifAbsent:
IdentityDictionary(Dictionary)>>at:ifAbsentPut:
EFFormatter>>formattedSourceFor:
EFFormatter>>willBeMultiline:
EFFormatter>>formatBlock:
[ self formatBlock: aBlockNode ] in EFFormatter>>visitBlockNode:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>bracketWith:around:
EFFormatter>>visitBlockNode:
RBBlockNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
EFFormatter>>visitNode:
[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
OrderedCollection(SequenceableCollection)>>withIndexDo:
EFFormatter>>formatSequenceNodeStatementsFor:
EFFormatter>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
[ 
			self newLines: (aMethodNode comments 
									ifEmpty: [ self numberOfNewLinesAfterMethodSignature ] 
			 						ifNotEmpty: [ self numberOfNewLinesAfterMethodSignatureWithMethodComment ]).
			self formatMethodCommentFor: aMethodNode.
			self formatPragmasFor: aMethodNode.
			self visitNode: aMethodNode body ] in EFFormatter>>formatMethodBodyFor:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>indent:around:
EFFormatter>>indentAround:
EFFormatter>>formatMethodBodyFor:
EFFormatter>>visitMethodNode:
RBMethodNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
EFFormatter>>format:
RBMethodNode(RBProgramNode)>>formattedCodeIn:
RBMethodNode(RBProgramNode)>>formattedCode
RBMethodNode>>newSource
ReReplaceNodeCritique>>change
ClyFixCritiqueCommand>>execute
ClyCriticContext>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
PopupChoiceDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>chooseIn:title:labels:values:lines:
MorphicUIManager>>chooseFrom:values:lines:title:
MorphicUIManager>>chooseFrom:lines:title:
OCCodeReparator>>openMenu
OpalCompiler>>checkNotice:
[ :n |
			| check |
			check := self checkNotice: n.
			check ifNil: [ ^ ast ].
			check ifFalse: [
				ast := nil.
				^ self failBlock ifNotNil: [ :block | block cull: n ] ifNil: [ nil ].
				] ] in OpalCompiler>>parse
OrderedCollection>>do:
OpalCompiler>>parse
OpalCompiler>>compile
OpalCompiler>>install
MyTestClassTest class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
MyTestClassTest class(ClassDescription)>>compile:classified:withStamp:notifying:
MyTestClassTest class(ClassDescription)>>compile:classified:notifying:
ClyMethodCreationToolMorph>>applyChanges
[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>on:do:
[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>ensure:
ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: RBCascadeNode >> #selector
9 October 2024 7:31:50.455 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

RBCascadeNode(Object)>>doesNotUnderstand: #selector
	Receiver: RBCascadeNode((aStream
	 nextPutAll: 'Yield: ';
	 nextPutAll: yield asString))
	Arguments and temporary variables: 
		aMessage: 	selector
		exception: 	Instance of RBCascadeNode did not understand #selector
		resumeValue: 	nil
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter>>isMultiLineMessage:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		aMessageNode: 	RBCascadeNode((aStream
	 nextPutAll: 'Yield: ';
	 nextPutAll:[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])] in [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


OrderedCollection(SequenceableCollection)>>do:separatedBy:
	Receiver: an OrderedCollection(RBMessageNode(aStream nextPutAll: 'Species: ' , species) RBMessag[..]
	Arguments and temporary variables: 
		elementBlock: 	[ :each | 
							self formatCommentsFor: each;
								forma[..]
		separatorBlock: 	[ 
					codeStream nextPut: $;.
					self newLineAfterCasca[..]
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(RBMessageNode(aStream nextPutAll: 'Species: ' , species) RB[..]
		firstIndex: 	1
		lastIndex: 	7


[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self [..]
	Arguments and temporary variables: 
		aBlock: 	[self indent: self indent - anInteger]
		handler: 	[self indent: self indent - anInteger]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	EFFormatter>>visitCascadeNode:
		compiledBlock: 	a CompiledBlock: [ 
			self newLineBeforeFirstCascade
				if[..]
		numArgs: 	0
		receiver: 	an EFFormatter


EFFormatter>>indent:around:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		anInteger: 	1
		aBlock: 	[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
	[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>indentAround:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		aBlock: 	[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
	[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


RBCascadeNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


OrderedCollection(SequenceableCollection)>>withIndexDo:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		elementAndIndexBlock: 	[:statement :i | 
		self visitNode: statement.
		(i <[..]
		index: 	1
	Receiver's instance variables: 
		array: 	<<error during printing>>

EFFormatter>>formatSequenceNodeStatementsFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>visitSequenceNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


RBSequenceNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>format:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	145
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ 
		  self class new
			indent: self indent;
			installNewContext: context;
			lookAheadCode: lookAheadCode;
			format: aNode ] in EFFormatter>>formattedSourceFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[self at: key put: aBlock value] in IdentityDictionary(Dictionary)>>at:ifAbsentPut:
	Receiver: an IdentityDictionary(RBMessageNode('Age: ' , age asString)->'''Age: '' , age asString[..]
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array(nil RBVariableNode(species)->'species' nil nil RBMessageNod[..]


IdentityDictionary(Dictionary)>>at:ifAbsent:
	Receiver: an IdentityDictionary(RBMessageNode('Age: ' , age asString)->'''Age: '' , age asString[..]
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array(nil RBVariableNode(species)->'species' nil nil RBMessageNod[..]


IdentityDictionary(Dictionary)>>at:ifAbsentPut:
	Receiver: an IdentityDictionary(RBMessageNode('Age: ' , age asString)->'''Age: '' , age asString[..]
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array(nil RBVariableNode(species)->'species' nil nil RBMessageNod[..]


EFFormatter>>formattedSourceFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>willBeMultiline:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>formatBlock:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ self formatBlock: aBlockNode ] in EFFormatter>>visitBlockNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self formatBlock: aBlockNode ]
	Arguments and temporary variables: 
		aBlock: 	[ codeStream nextPut: bracketString last ]
		handler: 	[ codeStream nextPut: bracketString last ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	EFFormatter>>visitBlockNode:
		compiledBlock: 	a CompiledBlock: [ self formatBlock: aBlockNode ]
		numArgs: 	0
		receiver: 	an EFFormatter


EFFormatter>>bracketWith:around:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	'[]'
		aBlock: 	[ self formatBlock: aBlockNode ]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>visitBlockNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


RBBlockNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printOn: aStream [
    aStream
        nextPutAll: ''Speci[..]
		lineStart: 	18
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode('Age: ' , age asString)-[..]



--- The full stack ---
RBCascadeNode(Object)>>doesNotUnderstand: #selector
EFFormatter>>isMultiLineMessage:
[ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])] in [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
OrderedCollection(SequenceableCollection)>>do:separatedBy:
[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>indent:around:
EFFormatter>>indentAround:
EFFormatter>>visitCascadeNode:
RBCascadeNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
OrderedCollection(SequenceableCollection)>>withIndexDo:
EFFormatter>>formatSequenceNodeStatementsFor:
EFFormatter>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
EFFormatter>>format:
[ 
		  self class new
			indent: self indent;
			installNewContext: context;
			lookAheadCode: lookAheadCode;
			format: aNode ] in EFFormatter>>formattedSourceFor:
[self at: key put: aBlock value] in IdentityDictionary(Dictionary)>>at:ifAbsentPut:
IdentityDictionary(Dictionary)>>at:ifAbsent:
IdentityDictionary(Dictionary)>>at:ifAbsentPut:
EFFormatter>>formattedSourceFor:
EFFormatter>>willBeMultiline:
EFFormatter>>formatBlock:
[ self formatBlock: aBlockNode ] in EFFormatter>>visitBlockNode:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>bracketWith:around:
EFFormatter>>visitBlockNode:
RBBlockNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
EFFormatter>>visitNode:
[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
OrderedCollection(SequenceableCollection)>>withIndexDo:
EFFormatter>>formatSequenceNodeStatementsFor:
EFFormatter>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
[ 
			self newLines: (aMethodNode comments 
									ifEmpty: [ self numberOfNewLinesAfterMethodSignature ] 
			 						ifNotEmpty: [ self numberOfNewLinesAfterMethodSignatureWithMethodComment ]).
			self formatMethodCommentFor: aMethodNode.
			self formatPragmasFor: aMethodNode.
			self visitNode: aMethodNode body ] in EFFormatter>>formatMethodBodyFor:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>indent:around:
EFFormatter>>indentAround:
EFFormatter>>formatMethodBodyFor:
EFFormatter>>visitMethodNode:
RBMethodNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
EFFormatter>>format:
RBMethodNode(RBProgramNode)>>formattedCodeIn:
RBMethodNode(RBProgramNode)>>formattedCode
RBMethodNode>>newSource
ReReplaceNodeCritique>>change
ClyFixCritiqueCommand>>execute
ClyCriticContext>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Slot #'wasFrost' appeared twice in ApricotTree
9 October 2024 8:47:32.676 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

[ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ] in [ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
	Receiver: a ShLayoutDefinition
	Arguments and temporary variables: 
		slotNames: 	#(#species #age #height #yield #fruitingAge #wasFrost)
		classSlotNames: 	#()
		aSubclass: 	ApricotTree
		anotherSlot: 	#wasFrost => InstanceVariableSlot
	Receiver's instance variables: 
		layoutClass: 	nil
		slots: 	{#species => InstanceVariableSlot. #age => InstanceVariableSlot. #he[..]
		classSlots: 	#()
		sharedPools: 	#()
		sharedVariables: 	#()
		builder: 	a ShiftClassBuilder


Array(SequenceableCollection)>>do:
	Receiver: {#wasFrost => InstanceVariableSlot}
	Arguments and temporary variables: 
		aBlock: 	[ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [..]
		index: 	1
	Receiver's instance variables: 
{#wasFrost => InstanceVariableSlot}

[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
	Receiver: a ShLayoutDefinition
	Arguments and temporary variables: 
		slotNames: 	#(#species #age #height #yield #fruitingAge #wasFrost)
		classSlotNames: 	#()
		aSubclass: 	ApricotTree
	Receiver's instance variables: 
		layoutClass: 	nil
		slots: 	{#species => InstanceVariableSlot. #age => InstanceVariableSlot. #he[..]
		classSlots: 	#()
		sharedPools: 	#()
		sharedVariables: 	#()
		builder: 	a ShiftClassBuilder


Array(SequenceableCollection)>>do:
	Receiver: {AppleTree. ApricotTree}
	Arguments and temporary variables: 
		aBlock: 	[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames[..]
		index: 	2
	Receiver's instance variables: 
{AppleTree. ApricotTree}

FruitTree class(Class)>>subclassesDo:
	Receiver: FruitTree
	Arguments and temporary variables: 
		aBlock: 	[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65541
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


ShLayoutDefinition>>validate
	Receiver: a ShLayoutDefinition
	Arguments and temporary variables: 
		slotNames: 	#(#species #age #height #yield #fruitingAge #wasFrost)
		classSlotNames: 	#()
	Receiver's instance variables: 
		layoutClass: 	nil
		slots: 	{#species => InstanceVariableSlot. #age => InstanceVariableSlot. #he[..]
		classSlots: 	#()
		sharedPools: 	#()
		sharedVariables: 	#()
		builder: 	a ShiftClassBuilder


ShiftClassBuilder>>build
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		buildEnvironment: 	a SystemDictionary(lots of globals)
		installingEnvironment: 	nil
		superclassName: 	#Object
		name: 	#FruitTree
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	FruitTree
		oldMetaclass: 	FruitTree class
		builderEnhancer: 	a ShDefaultBuilderEnhancer
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection(ShSharedPoolChangeDetector ShSharedVa[..]
		changes: 	a Set(a ShClassChanged a ShInstanceShapeChanged)
		metaSuperclass: 	nil
		superclassResolver: 	a ClassResolverStrictResolve
		inRemake: 	false
		package: 	'ProjectFruitTree'
		tag: 	nil


[
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.

		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.

		builder builderEnhancer propagateChangesToRelatedClasses: newClass builder: builder.
		
	] in ShiftClassInstaller>>make
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		builder: 	a ShiftClassBuilder


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		newClass := builder build.

		self installInEnvironment: newClass.

		self install[..]
	Arguments and temporary variables: 
		exception: 	ShNoChangesInClass
		handlerAction: 	[
		"If there are no changes in the building, I am not build[..]
	Receiver's instance variables: 
		outerContext: 	ShiftClassInstaller>>make
		compiledBlock: 	a CompiledBlock: [
		newClass := builder build.

		self inst[..]
		numArgs: 	0
		receiver: 	a ShiftClassInstaller


ShiftClassInstaller>>make
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		builder: 	a ShiftClassBuilder


ShiftClassInstaller>>makeWithBuilder:
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		aBuilder: 	a ShiftClassBuilder
	Receiver's instance variables: 
		builder: 	a ShiftClassBuilder


ShiftClassBuilder>>install
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		buildEnvironment: 	a SystemDictionary(lots of globals)
		installingEnvironment: 	nil
		superclassName: 	#Object
		name: 	#FruitTree
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	FruitTree
		oldMetaclass: 	FruitTree class
		builderEnhancer: 	a ShDefaultBuilderEnhancer
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection(ShSharedPoolChangeDetector ShSharedVa[..]
		changes: 	a Set(a ShClassChanged a ShInstanceShapeChanged)
		metaSuperclass: 	nil
		superclassResolver: 	a ClassResolverStrictResolve
		inRemake: 	false
		package: 	'ProjectFruitTree'
		tag: 	nil


ShiftClassBuilder>>fluidInstall
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		buildEnvironment: 	a SystemDictionary(lots of globals)
		installingEnvironment: 	nil
		superclassName: 	#Object
		name: 	#FruitTree
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	FruitTree
		oldMetaclass: 	FruitTree class
		builderEnhancer: 	a ShDefaultBuilderEnhancer
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection(ShSharedPoolChangeDetector ShSharedVa[..]
		changes: 	a Set(a ShClassChanged a ShInstanceShapeChanged)
		metaSuperclass: 	nil
		superclassResolver: 	a ClassResolverStrictResolve
		inRemake: 	false
		package: 	'ProjectFruitTree'
		tag: 	nil


ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClySystemEnvironment(Current image)
	Arguments and temporary variables: 
		newClass: 	a ShiftClassBuilder
		newClassDefinitionString: 	'Object << #FruitTree
	slots: { #species . #age .[..]
		aController: 	a RubScrolledTextMorph(800039424)
		oldClass: 	FruitTree
		newClassName: 	'FruitTree'
		compiler: 	an OpalCompiler
	Receiver's instance variables: 
		name: 	'Current image'
		globals: 	a SystemDictionary(lots of globals)
		changesAnnouncer: 	a SystemAnnouncer
		packageOrganizer: 	a PackageOrganizer
		projectManager: 	a ProjectManager


ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClyFullBrowserMorph(28046848)
	Arguments and temporary variables: 
		aString: 	'Object << #FruitTree
	slots: { #species . #age . #height . #yield[..]
		aController: 	a RubScrolledTextMorph(800039424)
		aClass: 	FruitTree
	Receiver's instance variables: 
		bounds: 	(65.0@46.0) corner: (980.0@664.0)
		owner: 	a SystemWindow(52386048) named: Method: FruitTree>>growOneYear:
		submorphs: 	an Array(a ProportionalSplitterMorph(1018842112) a PanelMorph(83[..]
		fullBounds: 	(65@46) corner: (980@664)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (771415552) [sticky]  [other:  (announcer -> an[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940[..]
		navigationPanel: 	a PanelMorph(174963456)
		navigationViews: 	an OrderedCollection(a ClyQueryViewMorph(420000768) a ClyQ[..]
		toolPanel: 	a PanelMorph(833352192)
		toolbar: 	a ClyToolbarMorph(840541440)
		tabManager: 	a ClyNotebookManager
		navigationHistory: 	a ClyNavigationHistory
		navigationStarted: 	false
		plugins: 	a SortedCollection(a ClyStandardBrowserPlugin a ClyInheritanceAnal[..]
		navigationEnvironment: 	a ClyNavigationEnvironment
		systemScope: 	a ClySystemEnvironmentScope(Current image)
		packageView: 	a ClyQueryViewMorph(420000768)
		classView: 	a ClyQueryViewMorph(774862848)
		methodGroupView: 	a ClyQueryViewMorph(309883904)
		methodView: 	a ClyQueryViewMorph(744892160)
		metaLevelScope: 	ClyInstanceSideScope
		methodGroupQuery: 	a ClyAllMethodGroupsQuery from inst. side: FruitTree


ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


ClyClassDefinitionEditorToolMorph>>applyChanges
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		code: 	a Text for 'Object << #FruitTree
	slots: { #species . #age . #height [..]
		ast: 	RBCascadeNode((Object << #FruitTree)
	slots: { #species. #age. #height[..]
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :err |
				  textModel setText: self editingText.
				  te[..]
	Receiver's instance variables: 
		outerContext: 	[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self chan[..]
		compiledBlock: 	a CompiledBlock: [
		  self changesAreAboutApply.
		  applie[..]
		numArgs: 	0
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  app[..]
	Arguments and temporary variables: 
		aBlock: 	[ applyingChanges := false]
		handler: 	[ applyingChanges := false]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>ch[..]
		compiledBlock: 	a CompiledBlock: [
		  textMorph hasUnacceptedEdits: true.
	[..]
		numArgs: 	0
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		aBlock: 	[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAre[..]
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


MessageSend>>value
	Receiver: MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph(53907200))
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


MessageSend>>cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph(53907200))
	Arguments and temporary variables: 
		arg: 	a RubTextAccepted
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


MessageSend>>cull:cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph(53907200))
	Arguments and temporary variables: 
		arg1: 	a RubTextAccepted
		arg2: 	an Announcer
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
	Receiver: an AnnouncementSubscription (a ClyClassDefinitionEditorToolMorph(53907200) subscribes [..]
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		action: 	MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph[..]
		subscriber: 	a ClyClassDefinitionEditorToolMorph(53907200)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx[..]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription(AbstractAnnouncementSubscription)>>d[..]
		compiledBlock: 	a CompiledBlock: [ action cull: anAnnouncement cull: announcer ]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription (a ClyClassDefinitionEditorToolMorph([..]


[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	nil
		ex: 	UnhandledError
		onDoCtx: 	nil
		handler: 	nil
		bottom: 	nil
		thisCtx: 	nil
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription(AbstractAnnouncementSubscription)>>d[..]
		compiledBlock: 	a CompiledBlock: [ action cull: anAnnouncement cull: announcer ]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription (a ClyClassDefinitionEditorToolMorph([..]



--- The full stack ---
[ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ] in [ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
Array(SequenceableCollection)>>do:
[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
Array(SequenceableCollection)>>do:
FruitTree class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.

		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.

		builder builderEnhancer propagateChangesToRelatedClasses: newClass builder: builder.
		
	] in ShiftClassInstaller>>make
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>makeWithBuilder:
ShiftClassBuilder>>install
ShiftClassBuilder>>fluidInstall
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>on:do:
[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Slot #'wasFrost' appeared twice in ApricotTree
9 October 2024 8:47:48.669 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

[ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ] in [ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
	Receiver: a ShLayoutDefinition
	Arguments and temporary variables: 
		slotNames: 	#(#species #age #height #yield #fruitingAge #wasFrost)
		classSlotNames: 	#()
		aSubclass: 	ApricotTree
		anotherSlot: 	#wasFrost => InstanceVariableSlot
	Receiver's instance variables: 
		layoutClass: 	nil
		slots: 	{#species => InstanceVariableSlot. #age => InstanceVariableSlot. #he[..]
		classSlots: 	#()
		sharedPools: 	#()
		sharedVariables: 	#()
		builder: 	a ShiftClassBuilder


Array(SequenceableCollection)>>do:
	Receiver: {#wasFrost => InstanceVariableSlot}
	Arguments and temporary variables: 
		aBlock: 	[ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [..]
		index: 	1
	Receiver's instance variables: 
{#wasFrost => InstanceVariableSlot}

[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
	Receiver: a ShLayoutDefinition
	Arguments and temporary variables: 
		slotNames: 	#(#species #age #height #yield #fruitingAge #wasFrost)
		classSlotNames: 	#()
		aSubclass: 	ApricotTree
	Receiver's instance variables: 
		layoutClass: 	nil
		slots: 	{#species => InstanceVariableSlot. #age => InstanceVariableSlot. #he[..]
		classSlots: 	#()
		sharedPools: 	#()
		sharedVariables: 	#()
		builder: 	a ShiftClassBuilder


Array(SequenceableCollection)>>do:
	Receiver: {AppleTree. ApricotTree}
	Arguments and temporary variables: 
		aBlock: 	[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames[..]
		index: 	2
	Receiver's instance variables: 
{AppleTree. ApricotTree}

FruitTree class(Class)>>subclassesDo:
	Receiver: FruitTree
	Arguments and temporary variables: 
		aBlock: 	[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65541
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


ShLayoutDefinition>>validate
	Receiver: a ShLayoutDefinition
	Arguments and temporary variables: 
		slotNames: 	#(#species #age #height #yield #fruitingAge #wasFrost)
		classSlotNames: 	#()
	Receiver's instance variables: 
		layoutClass: 	nil
		slots: 	{#species => InstanceVariableSlot. #age => InstanceVariableSlot. #he[..]
		classSlots: 	#()
		sharedPools: 	#()
		sharedVariables: 	#()
		builder: 	a ShiftClassBuilder


ShiftClassBuilder>>build
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		buildEnvironment: 	a SystemDictionary(lots of globals)
		installingEnvironment: 	nil
		superclassName: 	#Object
		name: 	#FruitTree
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	FruitTree
		oldMetaclass: 	FruitTree class
		builderEnhancer: 	a ShDefaultBuilderEnhancer
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection(ShSharedPoolChangeDetector ShSharedVa[..]
		changes: 	a Set(a ShClassChanged a ShInstanceShapeChanged)
		metaSuperclass: 	nil
		superclassResolver: 	a ClassResolverStrictResolve
		inRemake: 	false
		package: 	'ProjectFruitTree'
		tag: 	nil


[
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.

		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.

		builder builderEnhancer propagateChangesToRelatedClasses: newClass builder: builder.
		
	] in ShiftClassInstaller>>make
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		builder: 	a ShiftClassBuilder


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		newClass := builder build.

		self installInEnvironment: newClass.

		self install[..]
	Arguments and temporary variables: 
		exception: 	ShNoChangesInClass
		handlerAction: 	[
		"If there are no changes in the building, I am not build[..]
	Receiver's instance variables: 
		outerContext: 	ShiftClassInstaller>>make
		compiledBlock: 	a CompiledBlock: [
		newClass := builder build.

		self inst[..]
		numArgs: 	0
		receiver: 	a ShiftClassInstaller


ShiftClassInstaller>>make
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		builder: 	a ShiftClassBuilder


ShiftClassInstaller>>makeWithBuilder:
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		aBuilder: 	a ShiftClassBuilder
	Receiver's instance variables: 
		builder: 	a ShiftClassBuilder


ShiftClassBuilder>>install
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		buildEnvironment: 	a SystemDictionary(lots of globals)
		installingEnvironment: 	nil
		superclassName: 	#Object
		name: 	#FruitTree
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	FruitTree
		oldMetaclass: 	FruitTree class
		builderEnhancer: 	a ShDefaultBuilderEnhancer
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection(ShSharedPoolChangeDetector ShSharedVa[..]
		changes: 	a Set(a ShClassChanged a ShInstanceShapeChanged)
		metaSuperclass: 	nil
		superclassResolver: 	a ClassResolverStrictResolve
		inRemake: 	false
		package: 	'ProjectFruitTree'
		tag: 	nil


ShiftClassBuilder>>fluidInstall
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		buildEnvironment: 	a SystemDictionary(lots of globals)
		installingEnvironment: 	nil
		superclassName: 	#Object
		name: 	#FruitTree
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	FruitTree
		oldMetaclass: 	FruitTree class
		builderEnhancer: 	a ShDefaultBuilderEnhancer
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection(ShSharedPoolChangeDetector ShSharedVa[..]
		changes: 	a Set(a ShClassChanged a ShInstanceShapeChanged)
		metaSuperclass: 	nil
		superclassResolver: 	a ClassResolverStrictResolve
		inRemake: 	false
		package: 	'ProjectFruitTree'
		tag: 	nil


ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClySystemEnvironment(Current image)
	Arguments and temporary variables: 
		newClass: 	a ShiftClassBuilder
		newClassDefinitionString: 	'Object << #FruitTree
	slots: { #species . #age .[..]
		aController: 	a RubScrolledTextMorph(800039424)
		oldClass: 	FruitTree
		newClassName: 	'FruitTree'
		compiler: 	an OpalCompiler
	Receiver's instance variables: 
		name: 	'Current image'
		globals: 	a SystemDictionary(lots of globals)
		changesAnnouncer: 	a SystemAnnouncer
		packageOrganizer: 	a PackageOrganizer
		projectManager: 	a ProjectManager


ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClyFullBrowserMorph(28046848)
	Arguments and temporary variables: 
		aString: 	'Object << #FruitTree
	slots: { #species . #age . #height . #yield[..]
		aController: 	a RubScrolledTextMorph(800039424)
		aClass: 	FruitTree
	Receiver's instance variables: 
		bounds: 	(65.0@46.0) corner: (980.0@664.0)
		owner: 	a SystemWindow(52386048) named: Method: FruitTree>>growOneYear:
		submorphs: 	an Array(a ProportionalSplitterMorph(1018842112) a PanelMorph(83[..]
		fullBounds: 	(65@46) corner: (980@664)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (771415552) [sticky]  [other:  (announcer -> an[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940[..]
		navigationPanel: 	a PanelMorph(174963456)
		navigationViews: 	an OrderedCollection(a ClyQueryViewMorph(420000768) a ClyQ[..]
		toolPanel: 	a PanelMorph(833352192)
		toolbar: 	a ClyToolbarMorph(840541440)
		tabManager: 	a ClyNotebookManager
		navigationHistory: 	a ClyNavigationHistory
		navigationStarted: 	false
		plugins: 	a SortedCollection(a ClyStandardBrowserPlugin a ClyInheritanceAnal[..]
		navigationEnvironment: 	a ClyNavigationEnvironment
		systemScope: 	a ClySystemEnvironmentScope(Current image)
		packageView: 	a ClyQueryViewMorph(420000768)
		classView: 	a ClyQueryViewMorph(774862848)
		methodGroupView: 	a ClyQueryViewMorph(309883904)
		methodView: 	a ClyQueryViewMorph(744892160)
		metaLevelScope: 	ClyInstanceSideScope
		methodGroupQuery: 	a ClyAllMethodGroupsQuery from inst. side: FruitTree


ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


ClyClassDefinitionEditorToolMorph>>applyChanges
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		code: 	a Text for 'Object << #FruitTree
	slots: { #species . #age . #height [..]
		ast: 	RBCascadeNode((Object << #FruitTree)
	slots: { #species. #age. #height[..]
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :err |
				  textModel setText: self editingText.
				  te[..]
	Receiver's instance variables: 
		outerContext: 	[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self chan[..]
		compiledBlock: 	a CompiledBlock: [
		  self changesAreAboutApply.
		  applie[..]
		numArgs: 	0
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  app[..]
	Arguments and temporary variables: 
		aBlock: 	[ applyingChanges := false]
		handler: 	[ applyingChanges := false]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>ch[..]
		compiledBlock: 	a CompiledBlock: [
		  textMorph hasUnacceptedEdits: true.
	[..]
		numArgs: 	0
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		aBlock: 	[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAre[..]
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


MessageSend>>value
	Receiver: MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph(53907200))
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


MessageSend>>cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph(53907200))
	Arguments and temporary variables: 
		arg: 	a RubTextAccepted
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


MessageSend>>cull:cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph(53907200))
	Arguments and temporary variables: 
		arg1: 	a RubTextAccepted
		arg2: 	an Announcer
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
	Receiver: an AnnouncementSubscription (a ClyClassDefinitionEditorToolMorph(53907200) subscribes [..]
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		action: 	MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph[..]
		subscriber: 	a ClyClassDefinitionEditorToolMorph(53907200)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx[..]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription(AbstractAnnouncementSubscription)>>d[..]
		compiledBlock: 	a CompiledBlock: [ action cull: anAnnouncement cull: announcer ]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription (a ClyClassDefinitionEditorToolMorph([..]


[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	nil
		ex: 	UnhandledError
		onDoCtx: 	nil
		handler: 	nil
		bottom: 	nil
		thisCtx: 	nil
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription(AbstractAnnouncementSubscription)>>d[..]
		compiledBlock: 	a CompiledBlock: [ action cull: anAnnouncement cull: announcer ]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription (a ClyClassDefinitionEditorToolMorph([..]



--- The full stack ---
[ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ] in [ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
Array(SequenceableCollection)>>do:
[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
Array(SequenceableCollection)>>do:
FruitTree class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.

		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.

		builder builderEnhancer propagateChangesToRelatedClasses: newClass builder: builder.
		
	] in ShiftClassInstaller>>make
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>makeWithBuilder:
ShiftClassBuilder>>install
ShiftClassBuilder>>fluidInstall
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>on:do:
[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Slot #'wasFrost' appeared twice in ApricotTree
9 October 2024 8:48:50.757 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

[ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ] in [ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
	Receiver: a ShLayoutDefinition
	Arguments and temporary variables: 
		slotNames: 	#(#species #age #height #yield #fruitingAge #wasFrost)
		classSlotNames: 	#()
		aSubclass: 	ApricotTree
		anotherSlot: 	#wasFrost => InstanceVariableSlot
	Receiver's instance variables: 
		layoutClass: 	nil
		slots: 	{#species => InstanceVariableSlot. #age => InstanceVariableSlot. #he[..]
		classSlots: 	#()
		sharedPools: 	#()
		sharedVariables: 	#()
		builder: 	a ShiftClassBuilder


Array(SequenceableCollection)>>do:
	Receiver: {#wasFrost => InstanceVariableSlot}
	Arguments and temporary variables: 
		aBlock: 	[ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [..]
		index: 	1
	Receiver's instance variables: 
{#wasFrost => InstanceVariableSlot}

[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
	Receiver: a ShLayoutDefinition
	Arguments and temporary variables: 
		slotNames: 	#(#species #age #height #yield #fruitingAge #wasFrost)
		classSlotNames: 	#()
		aSubclass: 	ApricotTree
	Receiver's instance variables: 
		layoutClass: 	nil
		slots: 	{#species => InstanceVariableSlot. #age => InstanceVariableSlot. #he[..]
		classSlots: 	#()
		sharedPools: 	#()
		sharedVariables: 	#()
		builder: 	a ShiftClassBuilder


Array(SequenceableCollection)>>do:
	Receiver: {AppleTree. ApricotTree}
	Arguments and temporary variables: 
		aBlock: 	[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames[..]
		index: 	2
	Receiver's instance variables: 
{AppleTree. ApricotTree}

FruitTree class(Class)>>subclassesDo:
	Receiver: FruitTree
	Arguments and temporary variables: 
		aBlock: 	[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames[..]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65541
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


ShLayoutDefinition>>validate
	Receiver: a ShLayoutDefinition
	Arguments and temporary variables: 
		slotNames: 	#(#species #age #height #yield #fruitingAge #wasFrost)
		classSlotNames: 	#()
	Receiver's instance variables: 
		layoutClass: 	nil
		slots: 	{#species => InstanceVariableSlot. #age => InstanceVariableSlot. #he[..]
		classSlots: 	#()
		sharedPools: 	#()
		sharedVariables: 	#()
		builder: 	a ShiftClassBuilder


ShiftClassBuilder>>build
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		buildEnvironment: 	a SystemDictionary(lots of globals)
		installingEnvironment: 	nil
		superclassName: 	#Object
		name: 	#FruitTree
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	FruitTree
		oldMetaclass: 	FruitTree class
		builderEnhancer: 	a ShDefaultBuilderEnhancer
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection(ShSharedPoolChangeDetector ShSharedVa[..]
		changes: 	a Set(a ShClassChanged a ShInstanceShapeChanged)
		metaSuperclass: 	nil
		superclassResolver: 	a ClassResolverStrictResolve
		inRemake: 	false
		package: 	'ProjectFruitTree'
		tag: 	nil


[
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.

		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.

		builder builderEnhancer propagateChangesToRelatedClasses: newClass builder: builder.
		
	] in ShiftClassInstaller>>make
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		builder: 	a ShiftClassBuilder


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		newClass := builder build.

		self installInEnvironment: newClass.

		self install[..]
	Arguments and temporary variables: 
		exception: 	ShNoChangesInClass
		handlerAction: 	[
		"If there are no changes in the building, I am not build[..]
	Receiver's instance variables: 
		outerContext: 	ShiftClassInstaller>>make
		compiledBlock: 	a CompiledBlock: [
		newClass := builder build.

		self inst[..]
		numArgs: 	0
		receiver: 	a ShiftClassInstaller


ShiftClassInstaller>>make
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		builder: 	a ShiftClassBuilder


ShiftClassInstaller>>makeWithBuilder:
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		aBuilder: 	a ShiftClassBuilder
	Receiver's instance variables: 
		builder: 	a ShiftClassBuilder


ShiftClassBuilder>>install
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		buildEnvironment: 	a SystemDictionary(lots of globals)
		installingEnvironment: 	nil
		superclassName: 	#Object
		name: 	#FruitTree
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	FruitTree
		oldMetaclass: 	FruitTree class
		builderEnhancer: 	a ShDefaultBuilderEnhancer
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection(ShSharedPoolChangeDetector ShSharedVa[..]
		changes: 	a Set(a ShClassChanged a ShInstanceShapeChanged)
		metaSuperclass: 	nil
		superclassResolver: 	a ClassResolverStrictResolve
		inRemake: 	false
		package: 	'ProjectFruitTree'
		tag: 	nil


ShiftClassBuilder>>fluidInstall
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		buildEnvironment: 	a SystemDictionary(lots of globals)
		installingEnvironment: 	nil
		superclassName: 	#Object
		name: 	#FruitTree
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	FruitTree
		oldMetaclass: 	FruitTree class
		builderEnhancer: 	a ShDefaultBuilderEnhancer
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection(ShSharedPoolChangeDetector ShSharedVa[..]
		changes: 	a Set(a ShClassChanged a ShInstanceShapeChanged)
		metaSuperclass: 	nil
		superclassResolver: 	a ClassResolverStrictResolve
		inRemake: 	false
		package: 	'ProjectFruitTree'
		tag: 	nil


ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClySystemEnvironment(Current image)
	Arguments and temporary variables: 
		newClass: 	a ShiftClassBuilder
		newClassDefinitionString: 	'Object << #FruitTree
	slots: { #species . #age .[..]
		aController: 	a RubScrolledTextMorph(800039424)
		oldClass: 	FruitTree
		newClassName: 	'FruitTree'
		compiler: 	an OpalCompiler
	Receiver's instance variables: 
		name: 	'Current image'
		globals: 	a SystemDictionary(lots of globals)
		changesAnnouncer: 	a SystemAnnouncer
		packageOrganizer: 	a PackageOrganizer
		projectManager: 	a ProjectManager


ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClyFullBrowserMorph(28046848)
	Arguments and temporary variables: 
		aString: 	'Object << #FruitTree
	slots: { #species . #age . #height . #yield[..]
		aController: 	a RubScrolledTextMorph(800039424)
		aClass: 	FruitTree
	Receiver's instance variables: 
		bounds: 	(65.0@46.0) corner: (980.0@664.0)
		owner: 	a SystemWindow(52386048) named: Method: ApricotTree>>initializeTree:[..]
		submorphs: 	an Array(a ProportionalSplitterMorph(1018842112) a PanelMorph(83[..]
		fullBounds: 	(65@46) corner: (980@664)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (771415552) [sticky]  [other:  (announcer -> an[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940[..]
		navigationPanel: 	a PanelMorph(174963456)
		navigationViews: 	an OrderedCollection(a ClyQueryViewMorph(420000768) a ClyQ[..]
		toolPanel: 	a PanelMorph(833352192)
		toolbar: 	a ClyToolbarMorph(840541440)
		tabManager: 	a ClyNotebookManager
		navigationHistory: 	a ClyNavigationHistory
		navigationStarted: 	false
		plugins: 	a SortedCollection(a ClyStandardBrowserPlugin a ClyInheritanceAnal[..]
		navigationEnvironment: 	a ClyNavigationEnvironment
		systemScope: 	a ClySystemEnvironmentScope(Current image)
		packageView: 	a ClyQueryViewMorph(420000768)
		classView: 	a ClyQueryViewMorph(774862848)
		methodGroupView: 	a ClyQueryViewMorph(309883904)
		methodView: 	a ClyQueryViewMorph(744892160)
		metaLevelScope: 	ClyInstanceSideScope
		methodGroupQuery: 	a ClyAllMethodGroupsQuery from inst. side: ApricotTree


ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


ClyClassDefinitionEditorToolMorph>>applyChanges
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		code: 	a Text for 'Object << #FruitTree
	slots: { #species . #age . #height [..]
		ast: 	RBCascadeNode((Object << #FruitTree)
	slots: { #species. #age. #height[..]
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :err |
				  textModel setText: self editingText.
				  te[..]
	Receiver's instance variables: 
		outerContext: 	[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self chan[..]
		compiledBlock: 	a CompiledBlock: [
		  self changesAreAboutApply.
		  applie[..]
		numArgs: 	0
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  app[..]
	Arguments and temporary variables: 
		aBlock: 	[ applyingChanges := false]
		handler: 	[ applyingChanges := false]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>ch[..]
		compiledBlock: 	a CompiledBlock: [
		  textMorph hasUnacceptedEdits: true.
	[..]
		numArgs: 	0
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		aBlock: 	[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAre[..]
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassDefinitionEditorToolMorph(53907200)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(70.0@413.0) corner: (975.0@659.0)
		owner: 	a PanelMorph(225552384)
		submorphs: 	an Array(a ProportionalSplitterMorph(1045112576) a ClyQueryViewM[..]
		fullBounds: 	(70@413) corner: (975@659)
		color: 	Color transparent
		extension: 	a MorphExtension (143139328) [other:  (kmDispatcher -> a CmdKMDi[..]
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowserMorph(28046848)
		context: 	a ClyFullBrowserClassContext
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a ClyNotebookPageMorph(562344448)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(248409344)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(800039424)
		changesCancelRequested: 	false
		applyingChanges: 	true
		editingClass: 	FruitTree


MessageSend>>value
	Receiver: MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph(53907200))
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


MessageSend>>cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph(53907200))
	Arguments and temporary variables: 
		arg: 	a RubTextAccepted
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


MessageSend>>cull:cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph(53907200))
	Arguments and temporary variables: 
		arg1: 	a RubTextAccepted
		arg2: 	an Announcer
	Receiver's instance variables: 
		selector: 	#changesAccepted
		arguments: 	#()
		lookupClass: 	nil
		receiver: 	a ClyClassDefinitionEditorToolMorph(53907200)


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
	Receiver: an AnnouncementSubscription (a ClyClassDefinitionEditorToolMorph(53907200) subscribes [..]
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		action: 	MessageSend(#changesAccepted -> a ClyClassDefinitionEditorToolMorph[..]
		subscriber: 	a ClyClassDefinitionEditorToolMorph(53907200)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx[..]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription(AbstractAnnouncementSubscription)>>d[..]
		compiledBlock: 	a CompiledBlock: [ action cull: anAnnouncement cull: announcer ]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription (a ClyClassDefinitionEditorToolMorph([..]


[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	nil
		ex: 	UnhandledError
		onDoCtx: 	nil
		handler: 	nil
		bottom: 	nil
		thisCtx: 	nil
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription(AbstractAnnouncementSubscription)>>d[..]
		compiledBlock: 	a CompiledBlock: [ action cull: anAnnouncement cull: announcer ]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription (a ClyClassDefinitionEditorToolMorph([..]



--- The full stack ---
[ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ] in [ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
Array(SequenceableCollection)>>do:
[ :aSubclass |
		aSubclass slots do: [ :anotherSlot |
			(slotNames includes: anotherSlot name) ifTrue: [
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal
			] ]	 ] in ShLayoutDefinition>>validate
Array(SequenceableCollection)>>do:
FruitTree class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.

		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.

		builder builderEnhancer propagateChangesToRelatedClasses: newClass builder: builder.
		
	] in ShiftClassInstaller>>make
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>makeWithBuilder:
ShiftClassBuilder>>install
ShiftClassBuilder>>fluidInstall
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[
		  self changesAreAboutApply.
		  applied := self applyChanges ] in [
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>on:do:
[
		  textMorph hasUnacceptedEdits: true.
		  [
		  self changesAreAboutApply.
		  applied := self applyChanges ]
			  on: Error
			  do: [ :err |
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: true.
				  err pass ].

		  applied
			  ifTrue: [
				  textModel setText: self editingText.
				  textMorph hasUnacceptedEdits: false.
				  self textUpdated.
				  browser focusActiveTab ]
			  ifFalse: [ textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription(AbstractAnnouncementSubscription)>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
[ Processor terminateRealActive ] in [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction cull: ex ] ].

			  bottom := [ Processor terminateRealActive ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction cull: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ] in FullBlockClosure(BlockClosure)>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: AppleTree class >> #growOneYearWithFrost:
9 October 2024 9:17:39.869 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

AppleTree class(Object)>>doesNotUnderstand: #growOneYearWithFrost:
	Receiver: AppleTree
	Arguments and temporary variables: 
		aMessage: 	growOneYearWithFrost: false
		exception: 	Instance of AppleTree class did not understand #growOneYearWithF[..]
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#growOneYear:->AppleTree>>#growOneYear: #ini[..]
		format: 	65544
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#AppleTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		apple: 	AppleTree
		apricot: 	ApricotTree
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| apple apricot |
	"      [..]
		source: 	'| apple apricot |

"      [..]
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 505) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 505) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'| apple apricot |

"      [..]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
AppleTree class(Object)>>doesNotUnderstand: #growOneYearWithFrost:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: AppleTree class >> #growOneYear
9 October 2024 9:18:17.964 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

AppleTree class(Object)>>doesNotUnderstand: #growOneYear
	Receiver: AppleTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear
		exception: 	Instance of AppleTree class did not understand #growOneYear
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#growOneYear:->AppleTree>>#growOneYear: #ini[..]
		format: 	65544
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#AppleTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		apple: 	AppleTree
		apricot: 	ApricotTree
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| apple apricot |
	"      [..]
		source: 	'| apple apricot |

"      [..]
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->nil #apricot->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 466) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->nil #apricot->nil )
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 466) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'| apple apricot |

"      [..]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
AppleTree class(Object)>>doesNotUnderstand: #growOneYear
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: AppleTree class >> #growOneYear:
9 October 2024 9:18:49.488 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: AppleTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of AppleTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#growOneYear:->AppleTree>>#growOneYear: #ini[..]
		format: 	65544
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#AppleTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		apple: 	AppleTree
		apricot: 	ApricotTree
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| apple apricot |
	"      [..]
		source: 	'| apple apricot |

"      [..]
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->nil #apricot->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 469) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->nil #apricot->nil )
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 469) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'| apple apricot |

"      [..]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: AppleTree class >> #growOneYear:
9 October 2024 9:20:27.074 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: AppleTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of AppleTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#growOneYear:->AppleTree>>#growOneYear: #ini[..]
		format: 	65544
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#AppleTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		apple: 	AppleTree
		apricot: 	ApricotTree
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| apple apricot |
	"      [..]
		source: 	'| apple apricot |

"      [..]
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->nil #apricot->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 470) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->nil #apricot->nil )
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 470) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'| apple apricot |

"      [..]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: AppleTree class >> #growOneYear:
9 October 2024 9:20:41.917 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: AppleTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of AppleTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#growOneYear:->AppleTree>>#growOneYear: #ini[..]
		format: 	65544
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#AppleTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple growOneYear: false.
	apricot growOneYear: false
		source: 	'apple growOneYear: false.
apricot growOneYear: false.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: false.
apricot growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (197 to: 249) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
		aString: 	'apple growOneYear: false.
apricot growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (197 to: 249) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: false.
apricot growOneYear: false.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple growOneYear: false.
apricot growOneYear: false.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: ApricotTree class >> #growOneYear:
9 October 2024 9:20:59.069 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

ApricotTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: ApricotTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of ApricotTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#decreaseYield->ApricotTree>>#decreaseYield [..]
		format: 	65542
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#ApricotTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apricot growOneYear: false
		source: 	'apricot growOneYear: false.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apricot growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (223 to: 249) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
		aString: 	'apricot growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (223 to: 249) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apricot growOneYear: false.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apricot growOneYear: false.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
ApricotTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: AppleTree class >> #growOneYear:
9 October 2024 9:21:45.71 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: AppleTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of AppleTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#growOneYear:->AppleTree>>#growOneYear: #ini[..]
		format: 	65544
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#AppleTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple growOneYear: false
		source: 	'apple growOneYear: false.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (197 to: 221) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
		aString: 	'apple growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (197 to: 221) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: false.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple growOneYear: false.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: AppleTree class >> #growOneYear:
9 October 2024 9:21:57.758 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: AppleTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of AppleTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#growOneYear:->AppleTree>>#growOneYear: #ini[..]
		format: 	65544
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#AppleTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		apple: 	AppleTree
		apricot: 	ApricotTree
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| apple apricot |
	"      [..]
		source: 	'| apple apricot |

"      [..]
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 221) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 221) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'| apple apricot |

"      [..]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: AppleTree class >> #growOneYear:
9 October 2024 9:24:39.782 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: AppleTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: true
		exception: 	Instance of AppleTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#growOneYear:->AppleTree>>#growOneYear: #ini[..]
		format: 	65544
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#AppleTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple growOneYear: true. "  "
	apricot growOneYea[..]
		source: 	'apple growOneYear: true. "  "
apricot growOneYear: t[..]
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: true. "  "
apricot growOneYear: [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (283 to: 352) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
		aString: 	'apple growOneYear: true. "  "
apricot growOneYear: [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (283 to: 352) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: true. "  "
apricot growOneYear: [..]
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple growOneYear: true. "  "
apricot growOneYear[..]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: AppleTree class >> #growOneYear:
9 October 2024 9:26:03.756 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: AppleTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of AppleTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#growOneYear:->AppleTree>>#growOneYear: #ini[..]
		format: 	65544
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#AppleTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple growOneYear: false
		source: 	'apple growOneYear: false.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (197 to: 221) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
		aString: 	'apple growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (197 to: 221) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: false.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple growOneYear: false.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: AppleTree class >> #growOneYear:
9 October 2024 9:26:24.171 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: AppleTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of AppleTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#growOneYear:->AppleTree>>#growOneYear: #ini[..]
		format: 	65544
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#AppleTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		apple: 	AppleTree
		apricot: 	ApricotTree
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| apple apricot |
	"      [..]
		source: 	'| apple apricot |

"      [..]
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 221) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 221) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'| apple apricot |

"      [..]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: AppleTree class >> #growOneYear:
9 October 2024 9:28:12.312 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: AppleTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of AppleTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	FruitTree
		methodDict: 	a MethodDictionary(#growOneYear:->AppleTree>>#growOneYear: #ini[..]
		format: 	65544
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	#()
		name: 	#AppleTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		apple: 	AppleTree
		apricot: 	ApricotTree
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	| apple apricot |
	"      [..]
		source: 	'| apple apricot |

"      [..]
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 221) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
		aString: 	'| apple apricot |

"      [..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 221) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'| apple apricot |

"      [..]
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'| apple apricot |

"      [..]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
AppleTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FruitTree class >> #growOneYear:
9 October 2024 9:30:25.678 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: FruitTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of FruitTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65542
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple := FruitTree newWithDefaults.
	apricot := FruitTree newWi[..]
		source: 	'apple := FruitTree newWithDefaults.
apricot := FruitTree newWithDe[..]
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple := FruitTree newWithDefaults.
apricot := FruitTree newWithD[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (89 to: 219) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->AppleTree #apricot->ApricotTree )
		aString: 	'apple := FruitTree newWithDefaults.
apricot := FruitTree newWithD[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (89 to: 219) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple := FruitTree newWithDefaults.
apricot := FruitTree newWithD[..]
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple := FruitTree newWithDefaults.
apricot := FruitTree newWit[..]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FruitTree class >> #growOneYear:
9 October 2024 9:31:02.508 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: FruitTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of FruitTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65542
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple growOneYear: false
		source: 	'apple growOneYear: false.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (195 to: 219) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
		aString: 	'apple growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (195 to: 219) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: false.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'apple growOneYear: false.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	54
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FruitTree class >> #growOneYear:
9 October 2024 9:31:27.096 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: FruitTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of FruitTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65542
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple growOneYear: false
		source: 	'apple growOneYear: false.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (195 to: 219) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
		aString: 	'apple growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (195 to: 219) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple growOneYear: false.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple growOneYear: false.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FruitTree class >> #growOneYear
9 October 2024 9:31:37.488 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

FruitTree class(Object)>>doesNotUnderstand: #growOneYear
	Receiver: FruitTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear
		exception: 	Instance of FruitTree class did not understand #growOneYear
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65542
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple growOneYear
		source: 	'apple growOneYear'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple growOneYear'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (195 to: 211) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
		aString: 	'apple growOneYear'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (195 to: 211) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple growOneYear'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple growOneYear'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
FruitTree class(Object)>>doesNotUnderstand: #growOneYear
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FruitTree class >> #growOneYear:
9 October 2024 9:31:59.573 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: FruitTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of FruitTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65542
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple growOneYear: false
		source: 	'apple growOneYear:false.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple growOneYear:false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (195 to: 218) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
		aString: 	'apple growOneYear:false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (195 to: 218) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple growOneYear:false.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple growOneYear:false.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FruitTree class >> #printTree:
9 October 2024 9:37:00.845 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

FruitTree class(Object)>>doesNotUnderstand: #printTree:
	Receiver: FruitTree
	Arguments and temporary variables: 
		aMessage: 	printTree: Transcript
		exception: 	Instance of FruitTree class did not understand #printTree:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65542
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple printTree: Transcript
		source: 	'apple printTree: Transcript '
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple printTree: Transcript '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (428 to: 455) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
		aString: 	'apple printTree: Transcript '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (428 to: 455) ]
		text: 	an ObservableValueHolder[ '| apple apricot |

"  [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple printTree: Transcript '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple printTree: Transcript '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
FruitTree class(Object)>>doesNotUnderstand: #printTree:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FruitTree class >> #printTree:
9 October 2024 9:42:58.887 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

FruitTree class(Object)>>doesNotUnderstand: #printTree:
	Receiver: FruitTree
	Arguments and temporary variables: 
		aMessage: 	printTree: Transcript
		exception: 	Instance of FruitTree class did not understand #printTree:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65542
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple printTree: Transcript
		source: 	'apple printTree: Transcript. '
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple printTree: Transcript. '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (410 to: 438) ]
		text: 	an ObservableValueHolder[ '
"      [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
		aString: 	'apple printTree: Transcript. '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (410 to: 438) ]
		text: 	an ObservableValueHolder[ '
"      [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple printTree: Transcript. '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple printTree: Transcript. '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
FruitTree class(Object)>>doesNotUnderstand: #printTree:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FruitTree class >> #growOneYear:
9 October 2024 9:46:24.83 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: FruitTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of FruitTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65542
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple growOneYear: false
		source: 	'apple growOneYear:false.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple growOneYear:false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (173 to: 196) ]
		text: 	an ObservableValueHolder[ '
"      [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->FruitTree #apricot->FruitTree )
		aString: 	'apple growOneYear:false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (173 to: 196) ]
		text: 	an ObservableValueHolder[ '
"      [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple growOneYear:false.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple growOneYear:false.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FruitTree >> #printtree:
9 October 2024 9:50:54.521 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

FruitTree(Object)>>doesNotUnderstand: #printtree:
	Receiver: 
	Arguments and temporary variables: 
		aMessage: 	printtree: Transcript
		exception: 	Instance of FruitTree did not understand #printtree:
		resumeValue: 	nil
	Receiver's instance variables: 
		species: 	nil
		age: 	nil
		height: 	nil
		yield: 	nil
		fruitingAge: 	nil
		frostOccured: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple printtree: Transcript
		source: 	'apple printtree: Transcript. '
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple printtree: Transcript. '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple-> #apricot->FruitTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (399 to: 427) ]
		text: 	an ObservableValueHolder[ '
"      [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple-> #apricot->FruitTree )
		aString: 	'apple printtree: Transcript. '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (399 to: 427) ]
		text: 	an ObservableValueHolder[ '
"      [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple printtree: Transcript. '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple printtree: Transcript. '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
FruitTree(Object)>>doesNotUnderstand: #printtree:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: FruitTree class >> #growOneYear:
9 October 2024 9:51:18.399 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
	Receiver: FruitTree
	Arguments and temporary variables: 
		aMessage: 	growOneYear: false
		exception: 	Instance of FruitTree class did not understand #growOneYear:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->FruitTree>>#= #getYield->FruitTree>>#get[..]
		format: 	65542
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (initialization) - 2 selector(s) Protocol (as [..]
		subclasses: 	{AppleTree. ApricotTree}
		name: 	#FruitTree
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apricot growOneYear: false
		source: 	'apricot growOneYear: false.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apricot growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple-> #apricot->FruitTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (191 to: 217) ]
		text: 	an ObservableValueHolder[ '
"      [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple-> #apricot->FruitTree )
		aString: 	'apricot growOneYear: false.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (191 to: 217) ]
		text: 	an ObservableValueHolder[ '
"      [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apricot growOneYear: false.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apricot growOneYear: false.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
FruitTree class(Object)>>doesNotUnderstand: #growOneYear:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: RBCascadeNode >> #selector
9 October 2024 9:55:21.989 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

RBCascadeNode(Object)>>doesNotUnderstand: #selector
	Receiver: RBCascadeNode((aTranscript
	 show: 'Species: ';
	 show: species))
	Arguments and temporary variables: 
		aMessage: 	selector
		exception: 	Instance of RBCascadeNode did not understand #selector
		resumeValue: 	nil
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter>>isMultiLineMessage:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		aMessageNode: 	RBCascadeNode((aTranscript
	 show: 'Species: ';
	 show: species))
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


[ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])] in [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


OrderedCollection(SequenceableCollection)>>do:separatedBy:
	Receiver: an OrderedCollection(RBCascadeNode((aTranscript
	 show: 'Species: ';
	 show: species))[..]
	Arguments and temporary variables: 
		elementBlock: 	[ :each | 
							self formatCommentsFor: each;
								forma[..]
		separatorBlock: 	[ 
					codeStream nextPut: $;.
					self newLineAfterCasca[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(RBCascadeNode((aTranscript
	 show: 'Species: ';
	 show: spe[..]
		firstIndex: 	1
		lastIndex: 	7


[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self [..]
	Arguments and temporary variables: 
		aBlock: 	[self indent: self indent - anInteger]
		handler: 	[self indent: self indent - anInteger]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	EFFormatter>>visitCascadeNode:
		compiledBlock: 	a CompiledBlock: [ 
			self newLineBeforeFirstCascade
				if[..]
		numArgs: 	0
		receiver: 	an EFFormatter


EFFormatter>>indent:around:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		anInteger: 	1
		aBlock: 	[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
	[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>indentAround:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		aBlock: 	[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
	[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


RBCascadeNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


OrderedCollection(SequenceableCollection)>>withIndexDo:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		elementAndIndexBlock: 	[:statement :i | 
		self visitNode: statement.
		(i <[..]
		index: 	1
	Receiver's instance variables: 
		array: 	<<error during printing>>

EFFormatter>>formatSequenceNodeStatementsFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>visitSequenceNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


RBSequenceNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>format:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


[ 
		  self class new
			indent: self indent;
			installNewContext: context;
			lookAheadCode: lookAheadCode;
			format: aNode ] in EFFormatter>>formattedSourceFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


[self at: key put: aBlock value] in IdentityDictionary(Dictionary)>>at:ifAbsentPut:
	Receiver: an IdentityDictionary()
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


IdentityDictionary(Dictionary)>>at:ifAbsent:
	Receiver: an IdentityDictionary()
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


IdentityDictionary(Dictionary)>>at:ifAbsentPut:
	Receiver: an IdentityDictionary()
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


EFFormatter>>formattedSourceFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>willBeMultiline:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>formatBlock:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


[ self formatBlock: aBlockNode ] in EFFormatter>>visitBlockNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self formatBlock: aBlockNode ]
	Arguments and temporary variables: 
		aBlock: 	[ codeStream nextPut: bracketString last ]
		handler: 	[ codeStream nextPut: bracketString last ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	EFFormatter>>visitBlockNode:
		compiledBlock: 	a CompiledBlock: [ self formatBlock: aBlockNode ]
		numArgs: 	0
		receiver: 	an EFFormatter


EFFormatter>>bracketWith:around:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	'[]'
		aBlock: 	[ self formatBlock: aBlockNode ]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>visitBlockNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


RBBlockNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()



--- The full stack ---
RBCascadeNode(Object)>>doesNotUnderstand: #selector
EFFormatter>>isMultiLineMessage:
[ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])] in [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
OrderedCollection(SequenceableCollection)>>do:separatedBy:
[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>indent:around:
EFFormatter>>indentAround:
EFFormatter>>visitCascadeNode:
RBCascadeNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
OrderedCollection(SequenceableCollection)>>withIndexDo:
EFFormatter>>formatSequenceNodeStatementsFor:
EFFormatter>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
EFFormatter>>format:
[ 
		  self class new
			indent: self indent;
			installNewContext: context;
			lookAheadCode: lookAheadCode;
			format: aNode ] in EFFormatter>>formattedSourceFor:
[self at: key put: aBlock value] in IdentityDictionary(Dictionary)>>at:ifAbsentPut:
IdentityDictionary(Dictionary)>>at:ifAbsent:
IdentityDictionary(Dictionary)>>at:ifAbsentPut:
EFFormatter>>formattedSourceFor:
EFFormatter>>willBeMultiline:
EFFormatter>>formatBlock:
[ self formatBlock: aBlockNode ] in EFFormatter>>visitBlockNode:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>bracketWith:around:
EFFormatter>>visitBlockNode:
RBBlockNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
EFFormatter>>visitNode:
[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
OrderedCollection(SequenceableCollection)>>withIndexDo:
EFFormatter>>formatSequenceNodeStatementsFor:
EFFormatter>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
[ 
			self newLines: (aMethodNode comments 
									ifEmpty: [ self numberOfNewLinesAfterMethodSignature ] 
			 						ifNotEmpty: [ self numberOfNewLinesAfterMethodSignatureWithMethodComment ]).
			self formatMethodCommentFor: aMethodNode.
			self formatPragmasFor: aMethodNode.
			self visitNode: aMethodNode body ] in EFFormatter>>formatMethodBodyFor:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>indent:around:
EFFormatter>>indentAround:
EFFormatter>>formatMethodBodyFor:
EFFormatter>>visitMethodNode:
RBMethodNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
EFFormatter>>format:
RBMethodNode(RBProgramNode)>>formattedCodeIn:
RBMethodNode(RBProgramNode)>>formattedCode
RBMethodNode>>newSource
ReReplaceNodeCritique>>change
ClyFixCritiqueCommand>>execute
ClyCriticContext>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: RBCascadeNode >> #selector
9 October 2024 9:55:38.554 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

RBCascadeNode(Object)>>doesNotUnderstand: #selector
	Receiver: RBCascadeNode((aTranscript
	 show: 'Species: ';
	 show: species))
	Arguments and temporary variables: 
		aMessage: 	selector
		exception: 	Instance of RBCascadeNode did not understand #selector
		resumeValue: 	nil
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter>>isMultiLineMessage:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		aMessageNode: 	RBCascadeNode((aTranscript
	 show: 'Species: ';
	 show: species))
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


[ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])] in [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


OrderedCollection(SequenceableCollection)>>do:separatedBy:
	Receiver: an OrderedCollection(RBCascadeNode((aTranscript
	 show: 'Species: ';
	 show: species))[..]
	Arguments and temporary variables: 
		elementBlock: 	[ :each | 
							self formatCommentsFor: each;
								forma[..]
		separatorBlock: 	[ 
					codeStream nextPut: $;.
					self newLineAfterCasca[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(RBCascadeNode((aTranscript
	 show: 'Species: ';
	 show: spe[..]
		firstIndex: 	1
		lastIndex: 	7


[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self [..]
	Arguments and temporary variables: 
		aBlock: 	[self indent: self indent - anInteger]
		handler: 	[self indent: self indent - anInteger]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	EFFormatter>>visitCascadeNode:
		compiledBlock: 	a CompiledBlock: [ 
			self newLineBeforeFirstCascade
				if[..]
		numArgs: 	0
		receiver: 	an EFFormatter


EFFormatter>>indent:around:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		anInteger: 	1
		aBlock: 	[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
	[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>indentAround:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		aBlock: 	[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
	[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


RBCascadeNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


OrderedCollection(SequenceableCollection)>>withIndexDo:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		elementAndIndexBlock: 	[:statement :i | 
		self visitNode: statement.
		(i <[..]
		index: 	1
	Receiver's instance variables: 
		array: 	<<error during printing>>

EFFormatter>>formatSequenceNodeStatementsFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>visitSequenceNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


RBSequenceNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>format:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	12
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary()


[ 
		  self class new
			indent: self indent;
			installNewContext: context;
			lookAheadCode: lookAheadCode;
			format: aNode ] in EFFormatter>>formattedSourceFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


[self at: key put: aBlock value] in IdentityDictionary(Dictionary)>>at:ifAbsentPut:
	Receiver: an IdentityDictionary()
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


IdentityDictionary(Dictionary)>>at:ifAbsent:
	Receiver: an IdentityDictionary()
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


IdentityDictionary(Dictionary)>>at:ifAbsentPut:
	Receiver: an IdentityDictionary()
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


EFFormatter>>formattedSourceFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>willBeMultiline:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>formatBlock:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


[ self formatBlock: aBlockNode ] in EFFormatter>>visitBlockNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self formatBlock: aBlockNode ]
	Arguments and temporary variables: 
		aBlock: 	[ codeStream nextPut: bracketString last ]
		handler: 	[ codeStream nextPut: bracketString last ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	EFFormatter>>visitBlockNode:
		compiledBlock: 	a CompiledBlock: [ self formatBlock: aBlockNode ]
		numArgs: 	0
		receiver: 	an EFFormatter


EFFormatter>>bracketWith:around:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	'[]'
		aBlock: 	[ self formatBlock: aBlockNode ]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>visitBlockNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


RBBlockNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
        show: ''S[..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary()



--- The full stack ---
RBCascadeNode(Object)>>doesNotUnderstand: #selector
EFFormatter>>isMultiLineMessage:
[ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])] in [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
OrderedCollection(SequenceableCollection)>>do:separatedBy:
[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>indent:around:
EFFormatter>>indentAround:
EFFormatter>>visitCascadeNode:
RBCascadeNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
OrderedCollection(SequenceableCollection)>>withIndexDo:
EFFormatter>>formatSequenceNodeStatementsFor:
EFFormatter>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
EFFormatter>>format:
[ 
		  self class new
			indent: self indent;
			installNewContext: context;
			lookAheadCode: lookAheadCode;
			format: aNode ] in EFFormatter>>formattedSourceFor:
[self at: key put: aBlock value] in IdentityDictionary(Dictionary)>>at:ifAbsentPut:
IdentityDictionary(Dictionary)>>at:ifAbsent:
IdentityDictionary(Dictionary)>>at:ifAbsentPut:
EFFormatter>>formattedSourceFor:
EFFormatter>>willBeMultiline:
EFFormatter>>formatBlock:
[ self formatBlock: aBlockNode ] in EFFormatter>>visitBlockNode:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>bracketWith:around:
EFFormatter>>visitBlockNode:
RBBlockNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
EFFormatter>>visitNode:
[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
OrderedCollection(SequenceableCollection)>>withIndexDo:
EFFormatter>>formatSequenceNodeStatementsFor:
EFFormatter>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
[ 
			self newLines: (aMethodNode comments 
									ifEmpty: [ self numberOfNewLinesAfterMethodSignature ] 
			 						ifNotEmpty: [ self numberOfNewLinesAfterMethodSignatureWithMethodComment ]).
			self formatMethodCommentFor: aMethodNode.
			self formatPragmasFor: aMethodNode.
			self visitNode: aMethodNode body ] in EFFormatter>>formatMethodBodyFor:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>indent:around:
EFFormatter>>indentAround:
EFFormatter>>formatMethodBodyFor:
EFFormatter>>visitMethodNode:
RBMethodNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
EFFormatter>>format:
RBMethodNode(RBProgramNode)>>formattedCodeIn:
RBMethodNode(RBProgramNode)>>formattedCode
RBMethodNode>>newSource
ReReplaceNodeCritique>>change
ClyFixCritiqueCommand>>execute
ClyCriticContext>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: ThreadSafeTranscript >> #show
9 October 2024 10:00:13.258 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

ThreadSafeTranscript(Object)>>doesNotUnderstand: #show
	Receiver: Transcript
	Arguments and temporary variables: 
		aMessage: 	show
		exception: 	Instance of ThreadSafeTranscript did not understand #show
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		stream: 	a WriteStream
		accessSemaphore: 	a Mutex
		deferredClear: 	false
		deferredEndEntry: 	false
		stepContents: 	'After two years: 
'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	Transcript show
		source: 	'Transcript show.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Transcript show.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->a FruitTree #apricot->a FruitTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (356 to: 371) ]
		text: 	an ObservableValueHolder[ '
"      [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->a FruitTree #apricot->a FruitTree )
		aString: 	'Transcript show.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (356 to: 371) ]
		text: 	an ObservableValueHolder[ '
"      [..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'Transcript show.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'Transcript show.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(716502016)
		secondArg: 	a RubEditingArea(716502016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	5
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCom[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(716502016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(716502016)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor)[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkE[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding[..]
		morph: 	a RubEditingArea(716502016)
		directKeymaps: 	a KMCategory



--- The full stack ---
ThreadSafeTranscript(Object)>>doesNotUnderstand: #show
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: RBCascadeNode >> #selector
9 October 2024 10:08:30.853 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

RBCascadeNode(Object)>>doesNotUnderstand: #selector
	Receiver: RBCascadeNode((aTranscript open
	 show: ', Yield: ';
	 show: yield printString))
	Arguments and temporary variables: 
		aMessage: 	selector
		exception: 	Instance of RBCascadeNode did not understand #selector
		resumeValue: 	nil
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter>>isMultiLineMessage:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		aMessageNode: 	RBCascadeNode((aTranscript open
	 show: ', Yield: ';
	 show: [..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


[ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])] in [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


OrderedCollection(SequenceableCollection)>>do:separatedBy:
	Receiver: an OrderedCollection(RBMessageNode(aTranscript open show: 'Species: ' , species) RBMes[..]
	Arguments and temporary variables: 
		elementBlock: 	[ :each | 
							self formatCommentsFor: each;
								forma[..]
		separatorBlock: 	[ 
					codeStream nextPut: $;.
					self newLineAfterCasca[..]
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(RBMessageNode(aTranscript open show: 'Species: ' , species)[..]
		firstIndex: 	1
		lastIndex: 	7


[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self [..]
	Arguments and temporary variables: 
		aBlock: 	[self indent: self indent - anInteger]
		handler: 	[self indent: self indent - anInteger]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	EFFormatter>>visitCascadeNode:
		compiledBlock: 	a CompiledBlock: [ 
			self newLineBeforeFirstCascade
				if[..]
		numArgs: 	0
		receiver: 	an EFFormatter


EFFormatter>>indent:around:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		anInteger: 	1
		aBlock: 	[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
	[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>indentAround:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		aBlock: 	[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
	[..]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>visitCascadeNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


RBCascadeNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


OrderedCollection(SequenceableCollection)>>withIndexDo:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		elementAndIndexBlock: 	[:statement :i | 
		self visitNode: statement.
		(i <[..]
		index: 	1
	Receiver's instance variables: 
		array: 	<<error during printing>>

EFFormatter>>formatSequenceNodeStatementsFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>visitSequenceNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


RBSequenceNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>format:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	2
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	128
		context: 	an EFContext
		isInCascadeNode: 	true
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


[ 
		  self class new
			indent: self indent;
			installNewContext: context;
			lookAheadCode: lookAheadCode;
			format: aNode ] in EFFormatter>>formattedSourceFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


[self at: key put: aBlock value] in IdentityDictionary(Dictionary)>>at:ifAbsentPut:
	Receiver: an IdentityDictionary(RBMessageNode(', Age: ' , age printString)->''', Age: '' , age p[..]
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array(nil RBVariableNode(species)->'species' nil RBMessageNode(he[..]


IdentityDictionary(Dictionary)>>at:ifAbsent:
	Receiver: an IdentityDictionary(RBMessageNode(', Age: ' , age printString)->''', Age: '' , age p[..]
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array(nil RBVariableNode(species)->'species' nil RBMessageNode(he[..]


IdentityDictionary(Dictionary)>>at:ifAbsentPut:
	Receiver: an IdentityDictionary(RBMessageNode(', Age: ' , age printString)->''', Age: '' , age p[..]
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array(nil RBVariableNode(species)->'species' nil RBMessageNode(he[..]


EFFormatter>>formattedSourceFor:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>willBeMultiline:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>formatBlock:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


[ self formatBlock: aBlockNode ] in EFFormatter>>visitBlockNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self formatBlock: aBlockNode ]
	Arguments and temporary variables: 
		aBlock: 	[ codeStream nextPut: bracketString last ]
		handler: 	[ codeStream nextPut: bracketString last ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	EFFormatter>>visitBlockNode:
		compiledBlock: 	a CompiledBlock: [ self formatBlock: aBlockNode ]
		numArgs: 	0
		receiver: 	an EFFormatter


EFFormatter>>bracketWith:around:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	'[]'
		aBlock: 	[ self formatBlock: aBlockNode ]
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>visitBlockNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


RBBlockNode>>acceptVisitor:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an EFFormatter
	Receiver's instance variables: 
		parent: 	<<error during printing>>

EFFormatter(RBProgramNodeVisitor)>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]


EFFormatter>>bracketWith:around:indentExtraSpaces:
	Receiver: an EFFormatter
	Arguments and temporary variables: 
		bracketString: 	''
		aBlock: 	[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self sp[..]
		anInteger: 	0
	Receiver's instance variables: 
		codeStream: 	a ReadWriteStream
		indent: 	1
		originalSource: 	'printTree: aTranscript [
    aTranscript
		  open
        [..]
		lineStart: 	24
		context: 	an EFContext
		isInCascadeNode: 	false
		lookAheadCode: 	an IdentityDictionary(RBMessageNode(', Age: ' , age printStr[..]



--- The full stack ---
RBCascadeNode(Object)>>doesNotUnderstand: #selector
EFFormatter>>isMultiLineMessage:
[ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])] in [ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
OrderedCollection(SequenceableCollection)>>do:separatedBy:
[ 
			self newLineBeforeFirstCascade
				ifTrue: [ self newLine ]
				ifFalse: [ self space ].
			aCascadeNode messages
				do: [ :each | 
							self formatCommentsFor: each;
								formatSelectorAndArguments: each
								firstSeparator: [  ]
								restSeparator:
									((self isMultiLineMessage: each)
										ifTrue: [ [ self newLine ] ]
										ifFalse: [ [ self space ] ])]
				separatedBy: [ 
					codeStream nextPut: $;.
					self newLineAfterCascade
						ifTrue: [ self newLine ]
						ifFalse: [ self space ] ]
					] in EFFormatter>>visitCascadeNode:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>indent:around:
EFFormatter>>indentAround:
EFFormatter>>visitCascadeNode:
RBCascadeNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
OrderedCollection(SequenceableCollection)>>withIndexDo:
EFFormatter>>formatSequenceNodeStatementsFor:
EFFormatter>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
EFFormatter>>format:
[ 
		  self class new
			indent: self indent;
			installNewContext: context;
			lookAheadCode: lookAheadCode;
			format: aNode ] in EFFormatter>>formattedSourceFor:
[self at: key put: aBlock value] in IdentityDictionary(Dictionary)>>at:ifAbsentPut:
IdentityDictionary(Dictionary)>>at:ifAbsent:
IdentityDictionary(Dictionary)>>at:ifAbsentPut:
EFFormatter>>formattedSourceFor:
EFFormatter>>willBeMultiline:
EFFormatter>>formatBlock:
[ self formatBlock: aBlockNode ] in EFFormatter>>visitBlockNode:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>bracketWith:around:
EFFormatter>>visitBlockNode:
RBBlockNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
EFFormatter>>visitNode:
[:statement :i | 
		self visitNode: statement.
		(i < statements size
			or: [ 
				aSequenceNode parent
					ifNil: [ self periodsAtEndOfBlock or:[ self periodsAtEndOfMethod ] ]
					ifNotNil: [ :parent | 
						parent isBlock
							ifTrue: [ self periodsAtEndOfBlock ]
							ifFalse: [ self periodsAtEndOfMethod ] ] ])
			ifTrue: [ codeStream nextPut: $. ].
		self formatStatementCommentsFor: statement.
		i < statements size
			ifTrue: [ self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start ] ] in EFFormatter>>formatSequenceNodeStatementsFor:
OrderedCollection(SequenceableCollection)>>withIndexDo:
EFFormatter>>formatSequenceNodeStatementsFor:
EFFormatter>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
[ 
			self newLines: (aMethodNode comments 
									ifEmpty: [ self numberOfNewLinesAfterMethodSignature ] 
			 						ifNotEmpty: [ self numberOfNewLinesAfterMethodSignatureWithMethodComment ]).
			self formatMethodCommentFor: aMethodNode.
			self formatPragmasFor: aMethodNode.
			self visitNode: aMethodNode body ] in EFFormatter>>formatMethodBodyFor:
FullBlockClosure(BlockClosure)>>ensure:
EFFormatter>>indent:around:
EFFormatter>>indentAround:
EFFormatter>>formatMethodBodyFor:
EFFormatter>>visitMethodNode:
RBMethodNode>>acceptVisitor:
EFFormatter(RBProgramNodeVisitor)>>visitNode:
[ 
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ].
			super visitNode: aNode.
			(self formatCommentCloseToStatements or: [ aNode isMethod or: [ aNode isSequence or: [ aNode isBlock ] ] ])
				ifFalse: [  self spaceAndFormatComments: aNode. ].
			needsParenthesis
				ifTrue: [ codeStream nextPutAll: self spacesInsideParenthesesString ] ] in EFFormatter>>visitNode:
EFFormatter>>bracketWith:around:indentExtraSpaces:
EFFormatter>>visitNode:
EFFormatter>>format:
RBMethodNode(RBProgramNode)>>formattedCodeIn:
RBMethodNode(RBProgramNode)>>formattedCode
RBMethodNode>>newSource
ReReplaceNodeCritique>>change
ClyFixCritiqueCommand>>execute
ClyCriticContext>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: SystemWindow >> #show:
9 October 2024 10:11:13.549 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

SystemWindow(Object)>>doesNotUnderstand: #show:
	Receiver: a SystemWindow(97683200) named: Transcript
	Arguments and temporary variables: 
		aMessage: 	show: 'Species: Fig'
		exception: 	Instance of SystemWindow did not understand #show:
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(40.0@58.0) corner: (487.0@358.0)
		owner: 	a WorldMorph(987295744) [world]
		submorphs: 	an Array(a WindowEdgeGripMorph(11100160) a WindowEdgeGripMorph(8[..]
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (36031232) [other:  (kmDispatcher -> a KMDispat[..]
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	Transcript
		labelString: 	'Transcript'
		stripes: 	an Array(a Morph(1061613824) a Morph(176457216))
		label: 	a LabelMorph(42855936)'Transcript'
		closeBox: 	a MultistateButtonMorph(873500928)
		collapseBox: 	a MultistateButtonMorph(733223680)
		paneMorphs: 	an Array(a RubPluggableTextMorph(1030024192))
		collapsedFrame: 	nil
		fullFrame: 	(40.0@58.0) corner: (487.0@358.0)
		isCollapsed: 	false
		menuBox: 	a MultistateButtonMorph(752252928)
		mustNotClose: 	false
		labelWidgetAllowance: 	133
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(879531776)
		expandBox: 	a MultistateButtonMorph(88212736)
		embeddable: 	nil
		isResizeable: 	true
		taskbarTask: 	nil


FruitTree>>printTree:
	Receiver: a FruitTree
	Arguments and temporary variables: 
		aTranscript: 	Transcript
	Receiver's instance variables: 
		species: 	'Fig'
		age: 	0
		height: 	1.0
		yield: 	3
		fruitingAge: 	1
		frostOccured: 	false


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	apple := FruitTree new.

	apple initialize.
	Transcript open.
	[..]
		source: 	'apple := FruitTree new.

apple initialize.
Transcript open.
apple [..]
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'apple := FruitTree new.

apple initialize.
Transcript open.
apple[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->a FruitTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 88) ]
		text: 	an ObservableValueHolder[ 'apple := FruitTree new.

apple initialize.[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->a FruitTree )
		aString: 	'apple := FruitTree new.

apple initialize.
Transcript open.
apple[..]
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (1 to: 88) ]
		text: 	an ObservableValueHolder[ 'apple := FruitTree new.

apple initialize.[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'apple := FruitTree new.

apple initialize.
Transcript open.
apple[..]
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'apple := FruitTree new.

apple initialize.
Transcript open.
app[..]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	35
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryB[..]
		morph: 	a RubEditingArea(948815872)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtrlNavig[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtr[..]
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
SystemWindow(Object)>>doesNotUnderstand: #show:
FruitTree>>printTree:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: MyTestClass class >> #runCase
10 October 2024 12:15:01.234 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClass class(Object)>>doesNotUnderstand: #runCase
	Receiver: MyTestClass
	Arguments and temporary variables: 
		aMessage: 	runCase
		exception: 	Instance of MyTestClass class did not understand #runCase
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#counter->MyTestClass>>#counter #counter:->M[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (comparing) - 1 selector(s) Protocol (accessin[..]
		subclasses: 	#()
		name: 	#MyTestClass
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	MyTestClass runCase testDecrising
		source: 	'MyTestClass runCase testDecrising.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'MyTestClass runCase testDecrising.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->an AppleTree #apricot->an ApricotTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (585 to: 618) ]
		text: 	an ObservableValueHolder[ 'apple := AppleTree new.
apple initialize.
[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->an AppleTree #apricot->an ApricotTree )
		aString: 	'MyTestClass runCase testDecrising.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (585 to: 618) ]
		text: 	an ObservableValueHolder[ 'apple := AppleTree new.
apple initialize.
[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'MyTestClass runCase testDecrising.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'MyTestClass runCase testDecrising.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	35
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryB[..]
		morph: 	a RubEditingArea(948815872)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtrlNavig[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtr[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryB[..]
		morph: 	a RubEditingArea(948815872)
		directKeymaps: 	a KMCategory



--- The full stack ---
MyTestClass class(Object)>>doesNotUnderstand: #runCase
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: MyTestClass class >> #runTest:
10 October 2024 12:15:31.635 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClass class(Object)>>doesNotUnderstand: #runTest:
	Receiver: MyTestClass
	Arguments and temporary variables: 
		aMessage: 	runTest: nil
		exception: 	Instance of MyTestClass class did not understand #runTest:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#counter->MyTestClass>>#counter #counter:->M[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (comparing) - 1 selector(s) Protocol (accessin[..]
		subclasses: 	#()
		name: 	#MyTestClass
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	nil
		packageTag: 	a PackageTag(Uncategorized)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	MyTestClass runTest: testDecrising
		source: 	'MyTestClass runTest: testDecrising.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'MyTestClass runTest: testDecrising.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->an AppleTree #apricot->an ApricotTree )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (585 to: 619) ]
		text: 	an ObservableValueHolder[ 'apple := AppleTree new.
apple initialize.
[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->an AppleTree #apricot->an ApricotTree )
		aString: 	'MyTestClass runTest: testDecrising.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (585 to: 619) ]
		text: 	an ObservableValueHolder[ 'apple := AppleTree new.
apple initialize.
[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'MyTestClass runTest: testDecrising.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'MyTestClass runTest: testDecrising.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	35
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryB[..]
		morph: 	a RubEditingArea(948815872)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtrlNavig[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtr[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryB[..]
		morph: 	a RubEditingArea(948815872)
		directKeymaps: 	a KMCategory



--- The full stack ---
MyTestClass class(Object)>>doesNotUnderstand: #runTest:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: MyTestClassTest class >> #runAllTests
10 October 2024 12:17:32.431 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest class(Object)>>doesNotUnderstand: #runAllTests
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aMessage: 	runAllTests
		exception: 	Instance of MyTestClassTest class did not understand #runAllTests
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	MyTestClassTest runAllTests
		source: 	'MyTestClassTest runAllTests.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'MyTestClassTest runAllTests.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->an AppleTree #apricot->an ApricotTree #te[..]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (585 to: 612) ]
		text: 	an ObservableValueHolder[ 'apple := AppleTree new.
apple initialize.
[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->an AppleTree #apricot->an ApricotTree #te[..]
		aString: 	'MyTestClassTest runAllTests.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (585 to: 612) ]
		text: 	an ObservableValueHolder[ 'apple := AppleTree new.
apple initialize.
[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'MyTestClassTest runAllTests.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'MyTestClassTest runAllTests.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	35
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryB[..]
		morph: 	a RubEditingArea(948815872)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtrlNavig[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtr[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryB[..]
		morph: 	a RubEditingArea(948815872)
		directKeymaps: 	a KMCategory



--- The full stack ---
MyTestClassTest class(Object)>>doesNotUnderstand: #runAllTests
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: MyTestClassTest class >> #run
10 October 2024 12:18:46.335 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest class(Object)>>doesNotUnderstand: #run
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aMessage: 	run
		exception: 	Instance of MyTestClassTest class did not understand #run
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() [..]


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	MyTestClassTest run
		source: 	'MyTestClassTest run.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'MyTestClassTest run.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->an AppleTree #apricot->an ApricotTree #te[..]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (585 to: 604) ]
		text: 	an ObservableValueHolder[ 'apple := AppleTree new.
apple initialize.
[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->an AppleTree #apricot->an ApricotTree #te[..]
		aString: 	'MyTestClassTest run.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (585 to: 604) ]
		text: 	an ObservableValueHolder[ 'apple := AppleTree new.
apple initialize.
[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'MyTestClassTest run.'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'MyTestClassTest run.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	35
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryB[..]
		morph: 	a RubEditingArea(948815872)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtrlNavig[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtr[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryB[..]
		morph: 	a RubEditingArea(948815872)
		directKeymaps: 	a KMCategory



--- The full stack ---
MyTestClassTest class(Object)>>doesNotUnderstand: #run
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: ApricotTree >> #yield
10 October 2024 12:24:36.778 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

ApricotTree(Object)>>doesNotUnderstand: #yield
	Receiver: an ApricotTree
	Arguments and temporary variables: 
		aMessage: 	yield
		exception: 	Instance of ApricotTree did not understand #yield
		resumeValue: 	nil
	Receiver's instance variables: 
		species: 	'Apricot Tree'
		age: 	0
		height: 	1.0
		yield: 	0.0
		fruitingAge: 	3
		frostOccured: 	true


MyTestClassTest>>testDecrising
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		tree: 	an ApricotTree
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:24:36.656+03:00
		failures: 	a Set()
		errors: 	an OrderedCollection(MyTestClassTest>>#testDecrising)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 er[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:24:36.656+03:00
		failures: 	a Set()
		errors: 	an OrderedCollection(MyTestClassTest>>#testDecrising)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 erro[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 erro[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrising
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set(#testDecrising) #failures->a Set(#test[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrising
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrising)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrising))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrising))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(701803776)
		selectedItems: 	an Array(a ClyDataSourceItem(testDecrising))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
ApricotTree(Object)>>doesNotUnderstand: #yield
MyTestClassTest>>testDecrising
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Assertion failed
10 October 2024 12:29:55.938 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Assertion failed'
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Assertion failed'
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Assertion failed'
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(Object)>>assert:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		aBlock: 	false
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest>>testDecrising
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		tree: 	an ApricotTree
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:29:55.896+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrising)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:29:55.896+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrising)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrising
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrising
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrising)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrising))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrising))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(Object)>>assert:
MyTestClassTest>>testDecrising
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
QuestionWithoutCancelDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>questionWithoutCancelIn:text:title:
MorphicUIManager>>confirm:label:
MorphicUIManager>>confirm:
ClyFullBrowserMorph(Object)>>confirm:
ClyFullBrowserMorph(ClyBrowserMorph)>>confirmDiscardChanges
ClyMethodCodeEditorToolMorph(ClyBrowserToolMorph)>>okToClose
ClyNotebookManager>>closeTab:
[ self closeTab: tab ] in ClyNotebookManager>>addTool:
FullBlockClosure(BlockClosure)>>cull:
ClyNotebookPageHeaderPresenter>>doClose
[ :anEvent |
			anEvent isPrimaryButton
				ifTrue: [ self doClose ] ] in ClyNotebookPageHeaderPresenter>>initializePresenters
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseDown:fromMorph:
AlphaImageMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
AlphaImageMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
AlphaImageMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TabLabelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpNotebookTabSelectorMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyNotebookMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyFullBrowserMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: SmallInteger >> #self
10 October 2024 12:31:33.89 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #self
	Receiver: 0
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	Instance of SmallInteger did not understand #self
		resumeValue: 	nil
	Receiver's instance variables: 
0

MyTestClassTest>>testDecrising
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		tree: 	an ApricotTree
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:31:33.842+03:00
		failures: 	a Set()
		errors: 	an OrderedCollection(MyTestClassTest>>#testDecrising)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 er[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:31:33.842+03:00
		failures: 	a Set()
		errors: 	an OrderedCollection(MyTestClassTest>>#testDecrising)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 erro[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 erro[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrising
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrising
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrising)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrising))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrising))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(28046848)
		selectedItems: 	an Array(a ClyDataSourceItem(testDecrising))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #self
MyTestClassTest>>testDecrising
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Message not understood: SmallInteger >> #self
10 October 2024 12:32:12.651 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #self
	Receiver: 0
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	Instance of SmallInteger did not understand #self
		resumeValue: 	nil
	Receiver's instance variables: 
0

MyTestClassTest>>testDecrising
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		tree: 	an ApricotTree
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:32:12.617+03:00
		failures: 	a Set()
		errors: 	an OrderedCollection(MyTestClassTest>>#testDecrising)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 er[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:32:12.617+03:00
		failures: 	a Set()
		errors: 	an OrderedCollection(MyTestClassTest>>#testDecrising)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 erro[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 erro[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrising
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set(#testDecrising) #failures->a Set(#test[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrising
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrising)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrising))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrising))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(28046848)
		selectedItems: 	an Array(a ClyDataSourceItem(testDecrising))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #self
MyTestClassTest>>testDecrising
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Assertion failed
10 October 2024 12:32:28.791 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Assertion failed'
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Assertion failed'
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Assertion failed'
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(Object)>>assert:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		aBlock: 	false
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest>>testDecrising
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		tree: 	an ApricotTree
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:32:28.755+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrising)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:32:28.755+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrising)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrising
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrising
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrising)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrising))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrising))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(Object)>>assert:
MyTestClassTest>>testDecrising
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got 0.0 instead of 12.
10 October 2024 12:34:23.801 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got 0.0 instead of 12.'
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		actual: 	0.0
		expected: 	12
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest>>testDecrising
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		tree: 	an ApricotTree
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:34:23.765+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrising)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:34:23.765+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrising)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrising
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrising
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrising)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrising))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrising))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testDecrising
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got 0.0 instead of 12.
10 October 2024 12:35:34.633 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got 0.0 instead of 12.'
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		actual: 	0.0
		expected: 	12
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest>>testDecrising
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		tree: 	an ApricotTree
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrising
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:35:34.6+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrising)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrising
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:35:34.6+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrising)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrising


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrising
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrising
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrising
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrising
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrising)
		testSelector: 	#testDecrising
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrising)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrising))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrising))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrising))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testDecrising
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Assertion failed
10 October 2024 12:36:25.815 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Assertion failed'
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Assertion failed'
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Assertion failed'
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(Object)>>assert:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBlock: 	false
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest>>testDecrementing
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		counter: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:36:25.772+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:36:25.772+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrementing
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrementing)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrementing))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrementing))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(Object)>>assert:
MyTestClassTest>>testDecrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 4.
10 October 2024 12:40:34.868 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 4.'
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	4
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest>>testDecrementing
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		counter: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:40:34.814+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:40:34.814+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrementing
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrementing)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrementing))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrementing))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testDecrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 4.
10 October 2024 12:41:55.618 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 4.'
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	4
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest>>testDecrementing
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		counter: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:41:55.564+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:41:55.564+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrementing
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrementing)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrementing))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrementing))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testDecrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 4.
10 October 2024 12:42:08.318 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 4.'
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	4
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest>>testDecrementing
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		counter: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:42:08.277+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:42:08.277+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testIncrementing) [..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrementing
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrementing)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrementing))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrementing))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testDecrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 6.
10 October 2024 12:43:59.441 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 6.'
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	6
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest>>testIncrementing
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		counterT: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:43:59.395+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:43:59.395+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testIncrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing) [..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testIncrementing
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testIncrementing)
		testSelector: 	#testIncrementing
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testIncrementing)
		testSelector: 	#testIncrementing
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testIncrementing)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testIncrementing))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testIncrementing))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testIncrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 6.
10 October 2024 12:44:30.016 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 6.'
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	6
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest>>testIncrementing
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		counterT: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:44:29.97+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:44:29.97+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testIncrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testIncrementing
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testIncrementing)
		testSelector: 	#testIncrementing
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testIncrementing)
		testSelector: 	#testIncrementing
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testIncrementing)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testIncrementing))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testIncrementing))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testIncrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 4.
10 October 2024 12:50:23.072 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 4.'
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	4
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest>>testDecrementing
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		classT: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:50:23.016+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:50:23.016+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testIncrementing) [..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrementing
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrementing)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrementing))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrementing))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testDecrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 4.
10 October 2024 12:51:13.31 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 4.'
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	4
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest>>testDecrementing
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		classT: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testDecrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:51:13.268+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testDecrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:51:13.268+03:00
		failures: 	a Set(MyTestClassTest>>#testDecrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testDecrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testDecrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testDecrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testDecrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testIncrementing) [..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testDecrementing
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testDecrementing)
		testSelector: 	#testDecrementing
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testDecrementing)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testDecrementing))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testDecrementing))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testDecrementing))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testDecrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 6.
10 October 2024 12:52:35.834 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 6.'
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	6
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest>>testIncrementing
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		counterT: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:52:35.788+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:52:35.788+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testIncrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testIncrementing
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testIncrementing)
		testSelector: 	#testIncrementing
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testIncrementing)
		testSelector: 	#testIncrementing
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testIncrementing)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testIncrementing))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testIncrementing))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testIncrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 6.
10 October 2024 12:53:46.465 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 6.'
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	6
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest>>testIncrementing
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		counterT: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:53:46.43+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:53:46.43+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testIncrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testIncrementing
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testIncrementing)
		testSelector: 	#testIncrementing
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testIncrementing)
		testSelector: 	#testIncrementing
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testIncrementing)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testIncrementing))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testIncrementing))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testIncrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 6.
10 October 2024 12:54:33.483 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 6.'
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	6
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest>>testIncrementing
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		counterT: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:54:33.44+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:54:33.44+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testIncrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testIncrementing
		testClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testIncrementing)
		testSelector: 	#testIncrementing
		each: 	MyTestClassTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(MyTestClassTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each |
		self runTest: testSelector of: each ]
		index: 	3
		each: 	MyTestClassTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. MyTestClassTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testIncrementing)
		testSelector: 	#testIncrementing
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testIncrementing)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testIncrementing))
		runTestCases: 	{MyTestClassTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testIncrementing))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testIncrementing))


--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testIncrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each |
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 6.
10 October 2024 12:57:00.43 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 6.'
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	6
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest>>testIncrementing
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		counterT: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:57:00.387+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:57:00.387+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testIncrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing) [..]


[ :concreteClass |
		| testResult |
		testResult := concreteClass debug: selector.
		testResult updateResultsInHistory.
		GrowlMorph showTestResult: testResult with: selector ] in SycRunTestCommand>>execute
	Receiver: a SycRunTestCommand
	Arguments and temporary variables: 
		selector: 	#testIncrementing
		testClasses: 	{MyTestClassTest}
		concreteClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		method: 	MyTestClassTest>>#testIncrementing
		sourceNode: 	RBMessageNode(counterT increment)
		model: 	nil


Array(SequenceableCollection)>>do:
	Receiver: {MyTestClassTest}
	Arguments and temporary variables: 
		aBlock: 	[ :concreteClass |
		| testResult |
		testResult := concreteClass d[..]
		index: 	1
	Receiver's instance variables: 
{MyTestClassTest}

SycRunTestCommand>>execute
	Receiver: a SycRunTestCommand
	Arguments and temporary variables: 
		selector: 	#testIncrementing
		testClasses: 	{MyTestClassTest}
	Receiver's instance variables: 
		method: 	MyTestClassTest>>#testIncrementing
		sourceNode: 	RBMessageNode(counterT increment)
		model: 	nil


ClyMethodSourceCodeContext(ClySourceCodeContext)>>executeCommand:by:
	Receiver: a ClyMethodSourceCodeContext
	Arguments and temporary variables: 
		aCommand: 	a SycRunTestCommand
		aCommandActivator: 	a CmdCommandActivator(a SycRunTestCommand)
	Receiver's instance variables: 
		tool: 	a ClyMethodCodeEditorToolMorph(451628032)
		selectedSourceNode: 	RBMessageNode(counterT increment)


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a SycRunTestCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a SycRunTestCommand
		context: 	a ClyMethodSourceCodeContext
		activationStrategy: 	a SycSourceCodeMenuActivation(CmdRootMenuGroup; 1.4)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self app[..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		compiledBlock: 	a CompiledBlock: [self prepareCommandForExecution.
	context [..]
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a SycRunTestCommand)



--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testIncrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
[ :concreteClass |
		| testResult |
		testResult := concreteClass debug: selector.
		testResult updateResultsInHistory.
		GrowlMorph showTestResult: testResult with: selector ] in SycRunTestCommand>>execute
Array(SequenceableCollection)>>do:
SycRunTestCommand>>execute
ClyMethodSourceCodeContext(ClySourceCodeContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
CmdCommandActivator(Object)>>perform:orSendTo:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
SycOpenSourceCodeMenuCommand(CmdOpenContextMenuCommand)>>execute
SycOpenSourceCodeMenuCommand>>execute
ClyMethodSourceCodeContext(ClySourceCodeContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
CmdShortcutActivation>>tryExecuteCommandInContext:byEvents:
[ :shortcut |
		executed := shortcut tryExecuteCommandInContext: context byEvents: anEventBuffer.
		executed ifTrue: [ ^self ] ] in CmdKMDispatcher>>dispatch:
SortedCollection(SequenceableCollection)>>select:thenDo:
CmdShortcutActivation class(ClassAnnotation class)>>visibleInstancesInContext:do:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Got a MyTestClass instead of 6.
10 October 2024 12:57:22.164 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

MyTestClassTest(TestAsserter)>>assert:description:resumable:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got a MyTestClass instead of 6.'
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:description:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestAsserter)>>assert:equals:
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		actual: 	a MyTestClass
		expected: 	6
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest>>testIncrementing
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		counterT: 	a MyTestClass
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


MyTestClassTest(TestCase)>>performTest
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		self setUp.
		self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		handler: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [
		self setUp.
		self performTest ]
			ensure: [ self tear[..]
		compiledBlock: 	a CompiledBlock: [
		self setUp.
		self performTest ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanUpInstanceVariables ]
		handler: 	[ self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>runCase
		compiledBlock: 	a CompiledBlock: [ [
		self setUp.
		self performTest ]
			e[..]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>runCase
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just clo[..]
		handler: 	[
			"Terminated test is not considered as completed (user just cl[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not [..]
		compiledBlock: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed ([..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err |
			self handleException: err
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		compiledBlock: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Termi[..]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal tha[..]
		handler: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal th[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		compiledBlock: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		handler: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		compiledBlock: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anEx[..]
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the fol[..]
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critica[..]
		testCase: 	MyTestClassTest>>#testIncrementing
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#defa[..]
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (accessing) - 1 selector(s) Protocol (inheriti[..]
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	12284476
		packageTag: 	a PackageTag(Processes)
		soleInstance: 	a CurrentExecutionEnvironment


MyTestClassTest(TestCase)>>runCaseManaged
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:57:22.123+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	a[..]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		compiledBlock: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted with[..]
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 err[..]


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	MyTestClassTest>>#testIncrementing
	Receiver's instance variables: 
		timeStamp: 	2024-10-10T00:57:22.123+03:00
		failures: 	a Set(MyTestClassTest>>#testIncrementing)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[
		self classForTestResource resetResources: self resources.
		res[..]
		handler: 	[
		self classForTestResource resetResources: self resources.
		re[..]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MyTestClassTest(TestCase)>>debug
		compiledBlock: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	MyTestClassTest>>#testIncrementing


MyTestClassTest(TestCase)>>debug
	Receiver: MyTestClassTest>>#testIncrementing
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 error[..]
	Receiver's instance variables: 
		testSelector: 	#testIncrementing
		expectedFails: 	#()


MyTestClassTest class(TestCase class)>>debug:
	Receiver: MyTestClassTest
	Arguments and temporary variables: 
		aSymbol: 	#testIncrementing
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testCreatingMyTestClass->MyTestClassTest>>#[..]
		format: 	65538
		layout: 	a FixedLayout
		protocols: 	an Array(Protocol (basic tests) - 1 selector(s) Protocol (tests)[..]
		subclasses: 	nil
		name: 	#MyTestClassTest
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	1589
		packageTag: 	a PackageTag(Uncategorized)
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testDecrementing #[..]


[ :concreteClass |
		| testResult |
		testResult := concreteClass debug: selector.
		testResult updateResultsInHistory.
		GrowlMorph showTestResult: testResult with: selector ] in SycRunTestCommand>>execute
	Receiver: a SycRunTestCommand
	Arguments and temporary variables: 
		selector: 	#testIncrementing
		testClasses: 	{MyTestClassTest}
		concreteClass: 	MyTestClassTest
		testResult: 	nil
	Receiver's instance variables: 
		method: 	MyTestClassTest>>#testIncrementing
		sourceNode: 	RBMessageNode(counterT increment)
		model: 	nil


Array(SequenceableCollection)>>do:
	Receiver: {MyTestClassTest}
	Arguments and temporary variables: 
		aBlock: 	[ :concreteClass |
		| testResult |
		testResult := concreteClass d[..]
		index: 	1
	Receiver's instance variables: 
{MyTestClassTest}

SycRunTestCommand>>execute
	Receiver: a SycRunTestCommand
	Arguments and temporary variables: 
		selector: 	#testIncrementing
		testClasses: 	{MyTestClassTest}
	Receiver's instance variables: 
		method: 	MyTestClassTest>>#testIncrementing
		sourceNode: 	RBMessageNode(counterT increment)
		model: 	nil


ClyMethodSourceCodeContext(ClySourceCodeContext)>>executeCommand:by:
	Receiver: a ClyMethodSourceCodeContext
	Arguments and temporary variables: 
		aCommand: 	a SycRunTestCommand
		aCommandActivator: 	a CmdCommandActivator(a SycRunTestCommand)
	Receiver's instance variables: 
		tool: 	a ClyMethodCodeEditorToolMorph(451628032)
		selectedSourceNode: 	RBMessageNode(counterT increment)


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a SycRunTestCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a SycRunTestCommand
		context: 	a ClyMethodSourceCodeContext
		activationStrategy: 	a SycSourceCodeMenuActivation(CmdRootMenuGroup; 1.4)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self app[..]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		compiledBlock: 	a CompiledBlock: [self prepareCommandForExecution.
	context [..]
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a SycRunTestCommand)



--- The full stack ---
MyTestClassTest(TestAsserter)>>assert:description:resumable:
MyTestClassTest(TestAsserter)>>assert:description:
MyTestClassTest(TestAsserter)>>assert:equals:
MyTestClassTest>>testIncrementing
MyTestClassTest(TestCase)>>performTest
[
		self setUp.
		self performTest ] in [ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
[ [
		self setUp.
		self performTest ]
			ensure: [ self tearDown ] ] in MyTestClassTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
MyTestClassTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in MyTestClassTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
MyTestClassTest(TestCase)>>debug
MyTestClassTest class(TestCase class)>>debug:
[ :concreteClass |
		| testResult |
		testResult := concreteClass debug: selector.
		testResult updateResultsInHistory.
		GrowlMorph showTestResult: testResult with: selector ] in SycRunTestCommand>>execute
Array(SequenceableCollection)>>do:
SycRunTestCommand>>execute
ClyMethodSourceCodeContext(ClySourceCodeContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
CmdCommandActivator(Object)>>perform:orSendTo:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
SycOpenSourceCodeMenuCommand(CmdOpenContextMenuCommand)>>execute
SycOpenSourceCodeMenuCommand>>execute
ClyMethodSourceCodeContext(ClySourceCodeContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
CmdShortcutActivation>>tryExecuteCommandInContext:byEvents:
[ :shortcut |
		executed := shortcut tryExecuteCommandInContext: context byEvents: anEventBuffer.
		executed ifTrue: [ ^self ] ] in CmdKMDispatcher>>dispatch:
SortedCollection(SequenceableCollection)>>select:thenDo:
CmdShortcutActivation class(ClassAnnotation class)>>visibleInstancesInContext:do:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
receiver of "getCounter" is nil
10 October 2024 12:58:24.665 am

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 4041da92-80dd-0d00-9c4a-5c840e3463e4 Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo12.0.0SNAPSHOT [Build information: Pharo-12.0.0+SNAPSHOT.build.1538.sha.92f4878b0c2cc4439e2ee8700162de782d755027 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #getCounter
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	getCounter
		exception: 	#getCounter was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	counterT getCounter
		source: 	'	counterT getCounter.'
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		permitFaulty: 	false
		permitUndeclared: 	false
		failBlock: 	[ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncem[..]
		logged: 	nil
		changeStamp: 	nil
		protocol: 	nil
		requestor: 	a StPlaygroundInteractionModel
		priorMethod: 	nil


[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'	counterT getCounter.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		result: 	nil
		oldBindings: 	a Dictionary(#apple->an AppleTree #apricot->an ApricotTree #te[..]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (698 to: 718) ]
		text: 	an ObservableValueHolder[ 'apple := AppleTree new.
apple initialize.
[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
[..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e |
		self announcer announce: (SpCodeEvaluationFailedAnn[..]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		compiledBlock: 	a CompiledBlock: [
		self announcer announce: (SpCodeWillBeE[..]
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		result: 	nil
		oldBindings: 	a Dictionary(#apple->an AppleTree #apricot->an ApricotTree #te[..]
		aString: 	'	counterT getCounter.'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		actionGroup: 	a SpActionGroup
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		selection: 	an ObservableValueHolder[ (698 to: 718) ]
		text: 	an ObservableValueHolder[ 'apple := AppleTree new.
apple initialize.
[..]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		editable: 	an ObservableValueHolder[ true ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenu[..]
		scrollValue: 	an ObservableValueHolder[ (0@1.0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		smartCharacters: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]
		styleScheme: 	nil


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'	counterT getCounter.'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'	counterT getCounter.'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specC[..]
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		handler: 	[
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		compiledBlock: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put:[..]
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	13


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		protocols: 	#()
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		commentSourcePointer: 	68996924
		packageTag: 	a PackageTag(Presenters)
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(948815872)
		secondArg: 	a RubEditingArea(948815872)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		compiledBlock: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue:[..]
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted [..]
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCo[..]
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
	[..]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [[..]
	Arguments and temporary variables: 
		aBlock: 	[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchList[..]
		index: 	41
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
		[..]
	Receiver's instance variables: 
		tally: 	37
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx[..]


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(948815872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(948815872)


[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryB[..]
		morph: 	a RubEditingArea(948815872)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtrlNavig[..]
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
[..]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#MorphFocusCtr[..]
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryB[..]
		morph: 	a RubEditingArea(948815872)
		directKeymaps: 	a KMCategory



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #getCounter
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
[
		self announcer announce: (SpCodeWillBeEvaluatedAnnouncement newContent: aString).
		oldBindings := self interactionModel bindings copy.
		result := self interactionModel compiler
			source: aString;
			environment: self environment;
			failBlock:  [ 
				self announcer announce: (SpCodeEvaluationFailedAnnouncement newContent: aString).
				^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		self announcer announce: (SpCodeEvaluationSucceedAnnouncement newContent: aString).
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry |
		entry onMatchWith: anEventBuffer
			notify: aMatchListener
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget |
		"nice hack to stop in the first listener"
		aTarget
			verifyMatchWith: anEventBuffer
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
RubEditingArea(RubAbstractTextArea)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

